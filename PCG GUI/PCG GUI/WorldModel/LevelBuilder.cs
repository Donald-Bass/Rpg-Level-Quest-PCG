/* The levelBuilder class handles all the logic of building an actual final level from a given piece of input. 
 * This could be either from the output Clingo gives in which case the rough layout Clingo provides needs to be turned into an actual final layout or it could be 
 * from a file generated by the GUI containing a complete level in which case the file just needs to be read in and processed.
 */

using PCG_GUI.WorldModel;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Controls;

namespace PCG_GUI.Facts
{

    public class LevelBuilder
    {
        //Clingo seems to output its atoms in a semirandom order (There is definetly some logic there, but when I change the pcg code the order can change unpredicatably)
        //This is a problem because I need to process them in a specific order. As such I need to do a first pass through the input file to read all the relavent atoms and store them in
        //these lists so I can later go through them in the proper ordering
        private List<Atom> roomAtoms; //atoms giving information about rooms
        private List<Atom> edgeAtoms; //atoms giving information about connections between rooms
        private List<Atom> keyAtoms; //atoms giving information about the location of keys
        private List<Atom> tileAtoms; //atoms giving information about the layout of individual tiles

        //dimensions of the grid the level is laid out on. This is currently fixed as part of the pcg code. If this is changed in PCG.txt these values will need to be updated as well
        const int LEVEL_X_DIMENSION = 10; 
        const int LEVEL_Y_DIMENSION = 10;

        public int numRooms; //how many rooms are there in the level

        private Level pcgLevel; //the actual level generated

        private List<List<Template>> allTemplates; //list of lists of all templates. Currently (and I admit this is ugly, index 0 is boss rooms, 1 is treasure rooms, 2 is gauntlets, 
                                                   //3 is entrances, and 4 is generic rooms
        //variables storing said index
        const int BOSS_INDEX = 0;
        const int TREASURE_INDEX = 1;
        const int GAUNTLET_INDEX = 2;
        const int ENTRANCE_INDEX = 3;
        const int GENERIC_INDEX = 4;

        int loadedLevelX; //if a complete level is loaded from a file (as opposed to recieving input from Clingo) this stores the size of the x Axis
        int loadedLevelY; //if a complete level is loaded from a file (as opposed to recieving input from Clingo) this stores the size of the y Axis

        //Constructor
        public LevelBuilder()
        {
            roomAtoms = new List<Atom>();
            edgeAtoms = new List<Atom>();
            keyAtoms = new List<Atom>();
            tileAtoms = new List<Atom>();

            //set up the templates
            allTemplates = new List<List<Template>>();

            //right now the order I read these files in are important. There is no way of matching a room type to a specific index in the list other then looking up a predefined index the templates 
            //for that room type should be at. This is ugly and should be changed at some point but it works
            List<Template> curTemplatesList = readTemplates("boss.txt");
            allTemplates.Add(curTemplatesList);
            curTemplatesList = readTemplates("treasure.txt");
            allTemplates.Add(curTemplatesList);
            curTemplatesList = readTemplates("gauntlet.txt");
            allTemplates.Add(curTemplatesList);
            curTemplatesList = readTemplates("entrance.txt");
            allTemplates.Add(curTemplatesList);
            curTemplatesList = readTemplates("generic.txt");
            allTemplates.Add(curTemplatesList);
        }

        /*This reads in a series of templates from an input file and returns a list of them. The file format is simple
        * The first line is a single number which is the number of templates in the file
        * The next line starts the first template. 
        * The first line of the template is the x  dimensions of the template
        * and the second is the y
        * Each additional line holds one row of the template detailing each tile. Currently
        *       . is floor
        *      # is blocked terrain
        * This function does no error checking currently      
        */
        public List<Template> readTemplates(string templateFile)
        {
            List<Template> tList = new List<Template>();

            System.IO.StreamReader file = new System.IO.StreamReader(templateFile); //open the template file

            int numTemplates = int.Parse(file.ReadLine()); //the first line is the number of templates

            for (int i = 0; i < numTemplates; i++) //for each template
            {
                int xDimension = int.Parse(file.ReadLine()); //the first line of a template is the x dimension of the template
                int yDimension = int.Parse(file.ReadLine()); //the second line of a template is the y dimension of the template

                Template curTemplate = new Template(xDimension, yDimension);

                //read in each line of the template
                for(int j = 0; j < yDimension; j++)
                {
                    string templateRow = file.ReadLine();

                    for(int k = 0; k < xDimension; k++) //for each tile in the line
                    {
                        switch(templateRow[k])
                        {
                            case '#':
                                curTemplate.setTileType(k, j, TileType.blocked);
                                break;
                            case '.':
                                curTemplate.setTileType(k, j, TileType.floor);
                                break;
                        }
                    }
                }

                //add the finished template to the list
                tList.Add(curTemplate);

            }

            file.Close();

            return tList; //return the list of templates
        }

        //This function does the inital work of processing an input file. This means it reads in the entire file, parses all the atoms, and then calls the appropiate function based on what type of file it
        //is. (Output from Clingo, or a complete level output by the GUI)
        public void parseInputFile(System.IO.StreamReader file)
        {
            Atom curFact;
            
            String firstLine = file.ReadLine(); //the first line notes whether this is a input file from Clingo or an already complete level saved by the GUI
            file.ReadLine(); //the next 3 lines contain nothing useful
            file.ReadLine();
            file.ReadLine(); 

            String[] StringFacts = file.ReadLine().Trim().Split(' '); //the fifth line has all the output so split all the atoms into seperate strings

            for (int i = 0; i < StringFacts.Length; i++ ) //for each atom
            {
                curFact = new Atom(StringFacts[i]);
                sortFact(curFact);
            }

            if (firstLine.Equals("COMPLETE")) //if this was marked as output from the GUI (ie the fist line is COMPLETE) load a completed level
            {
                loadLevel();
            }

            else //otherwise finish a partially made level from Clingo
            {
                buildLevels();
            }
            //return allFacts;
        }

        //Save the current level to a file. (This doesn't check that a level actually exists but the way the code is structured makes it impossible for it not to be the case, right now). 
        public void saveLevel(System.IO.StreamWriter file)
        {
            file.WriteLine("COMPLETE"); //the clingo output has 4 unecessary line at the start so use the first line to denote that this is not the clingo output file
                                        //and then add 3 more to match the format
            file.WriteLine("");
            file.WriteLine(""); 
            file.WriteLine("");

            pcgLevel.write(file);
        }

        //Look at a specific atom and decide what type of atom this is based on the name of the atom, and finally store it in the appropriate list for later use
        private void sortFact(Atom fact)
        {
            switch (fact.getAtomName())
            {
                //Below this point are atoms that are used either when loading a partialy finished level from Clingo or a completed level finished by the GUI
                //The meaning may change though based on which one it is
                case "room":                //room atoms encode specific rooms in the level. The two types of input files though have different formats for this atom
                    roomAtoms.Add(fact);
                    break;
                //These are atoms currently only used when reading in partially complete levels from Clingo
                case "numRooms": //if the atom specifies the number of rooms we can use that information right now.
                    numRooms = fact.getNumericValue(0); //set the number of rooms to the value in the atom
                    break;
                case "uniqueEdge": //this denotes an edge connecting two rooms, with said edge only being encoded in a single atom in the output file (this means you don't see uniqueEdge(u,v)
                                   //and uniqueEdge(v,u) which are the same edge since our underlying graph is undirected
                    edgeAtoms.Add(fact);
                    break;
                case "uniqueLock": //this is an alternative atom to the above with the same properties, that is used instead of uniqueEdges, for edges that are locked in some fashion
                    edgeAtoms.Add(fact);
                    break;
                case "keyRoom": //this denotes a room that contains a key
                    keyAtoms.Add(fact);
                    break;
                //Below this point are atoms used exclusively for loaded already completed levels
                //the next five atoms encode various types of tiles
                case "floor": 
                case "door" :
                case "startingRoom":
                case "lock":
                case "key":
                    tileAtoms.Add(fact);
                    break;
                //the last two give the dimensions of the level. As with numRooms this information is useable right away and does not require storage in a list
                case "levelLengthX": 
                    loadedLevelX = fact.getNumericValue(0); //set the x dimension of the level to the atom's value
                    break;
                case "levelLengthY":
                    loadedLevelY = fact.getNumericValue(0); //set the y dimension of the level to the atom's value
                    break;
            }
        }

        //This function takes a level fully defined in an input file(i.e it was output by the GUI not clingo) and loads it into memory. This should only get called
        //At the end of the parseInputFile as it assumes said function has been run and sorted all the atoms in the input file have been sorted into the appropiate lists
        private void loadLevel()
        {
            pcgLevel = new Level(loadedLevelX, loadedLevelY); //create a new level of the right size

            foreach (Atom t in tileAtoms) //go through all atoms encoding tiles and place them in the level
            {
                //get information about the tile (generally a tile atom denotes the type of tile by its name and has two values giving the x and y coordinates of said tile)
                int x = t.getNumericValue(0); //x coordinate of tile
                int y = t.getNumericValue(1); //y coordinate of tile
                TileType type = TileType.undefined; //type of tile to add


                switch(t.getAtomName()) //get the type of tile to place based on the atom's name
                {
                    case "floor":
                        type = TileType.floor;
                        break;
                    case "door":
                        type = TileType.door;
                        break;
                    case "startingRoom":
                        type = TileType.startingRoom;
                        break;
                    case "key": //if the tile is a key there is a third value with the number of the key. get that value and store it
                        type = TileType.key;
                        pcgLevel.setTileAdditionalInformation(x,y,t.getNumericValue(2)); //extract the key number and store it
                        pcgLevel.levelMap[x, y].RoomNumber = t.getNumericValue(2); //set the room number of the tile to the key number as a quick hack to get the number displayed
                        break;
                    case "lock": //if the tile is a locked door there is a third value with the number of the key that opens it. get that value and store it
                        type = TileType.locked;
                        pcgLevel.setTileAdditionalInformation(x, y, t.getNumericValue(2)); //extract the key number and store it
                        pcgLevel.levelMap[x, y].RoomNumber = t.getNumericValue(2); //set the room number of the tile to the key number as a quick hack to get the number displayed
                        break;
                }

                pcgLevel.setTileType(x, y, type); //add the tile to the level
            }
           
            foreach (Atom r in roomAtoms) //go through all the atoms encoding rooms and store the resulting rooms in the pcgLevelObject
            {
                pcgLevel.addRoom(r.getNumericValue(0), r.getNumericValue(1), r.getNumericValue(2), r.getNumericValue(3), r.getNumericValue(4), r.getValue(5));
            }

            pcgLevel.finalizeLevel(); //finalize the level (i.e block off all tiles that were never defined)
        }

        //This function takes a level partially defined in an input file(i.e it was output by Clingo and not the GUI) and builds a full level that fits said definition. This should only get called
        //At the end of the parseInputFile as it assumes said function has been run and sorted all the atoms in the input file have been sorted into the appropiate lists
        private void buildLevels()
        {
            //The algorithm to build the level has 3 main steps, and a fourth smaller step

            //Step 1. Determine the ultimate dimensions of the level. To do so create a grid with the positions of all the rooms then for each room we decide what layout to give said room, and finally
            //use the size of said layouts to determine the number of tiles across each column should be and tiles up each row should be. (These rows and columns refer to the 10 by 10 grid Clingo lays
            //rooms out on, not the rows and columns in the final level)
            //Step 2. Place the actual rooms in the leve
            //Step 3. Place corridors between rooms and doors at the ends of said corridors
            //Step 4. Place keys as necessary

            int[] columnWidths = new int[LEVEL_X_DIMENSION]; //how many tiles across is each column
            int[] rowHeights = new int[LEVEL_Y_DIMENSION]; //how many tiles high is each row

            int[] roomXCenter = new int[numRooms]; //what is the x coordinate of the center of each room
            int[] roomYCenter = new int[numRooms]; //what is the y coordinate of the center of each room

            int[] templateIndex = new int[numRooms]; //what is the index of the specific template the room is based off of. This is the index for the list specific for the templates of thr type of room 
                                                     //a given room is. Determing which index of the allTemplates list contains the desired list is determined dynamically on the fly

            int x, y; //used to hold various coordinates

            Random rng = new Random(); //Random number generating for chosing random templates

            //For each room read in the row and column the room is in on the basic grid Clingo used to lay them out (X is the column and Y is the row)
            //Then determine how big the room should be, and if the column/row isn't large enough to hold the room, increase the size of said row/column
            foreach (Atom f in roomAtoms) //read in each room
            {
                //the room atom has the format room(N,X,Y,T) where N is the room number, X and Y are coordinates, and T is the type of room
                int roomNumber = f.getNumericValue(0) - 1; //convert the room number to being zero indexed
                x = f.getNumericValue(1); 
                y = f.getNumericValue(2);
                string roomType = f.getValue(3);

                int roomDimensionX = 0; //the x dimension of the room
                int roomDimensionY = 0; //the y dimension of the room

                int allTemplateIndex; //what index of the allTemplate list do we need to get the list of templates we want

                //determine the index of the proper list of templates for our room type
                if (roomType.Equals("boss"))
                {
                    allTemplateIndex = BOSS_INDEX;
                }

                else if (roomType.Equals("gauntlet"))
                {
                    allTemplateIndex = GAUNTLET_INDEX;
                }

                else if (roomType.Equals("treasure"))
                {
                    allTemplateIndex = TREASURE_INDEX; 
                }

                else if (roomType.Equals("entrance"))
                {
                    allTemplateIndex = ENTRANCE_INDEX; 
                }

                else //if (roomType.Equals("generic")) For now as a fail safe assume all rooms that are none of the above are generic rooms
                {
                    allTemplateIndex = GENERIC_INDEX; 

                }

                //chose a random template from the proper list and gets it's dimensions
                templateIndex[roomNumber] = rng.Next(allTemplates[allTemplateIndex].Count);
                roomDimensionX = allTemplates[allTemplateIndex][templateIndex[roomNumber]].xDimension;
                roomDimensionY = allTemplates[allTemplateIndex][templateIndex[roomNumber]].yDimension;


                //Increase the dimensions by 2 so there is a 1 tile boundary around the largest sized room
                roomDimensionX += 2;
                roomDimensionY += 2;

                //if the room is too big to fit in the current row/column increase the size of said room/column

                if (rowHeights[y] < roomDimensionY)
                {
                    rowHeights[y] = roomDimensionY;
                }

                if (columnWidths[x] < roomDimensionX)
                {
                    columnWidths[x] = roomDimensionX;
                }
            }

            //find the total width and height of the level by adding all row / column sizes
            int width = 0;
            foreach(int i in columnWidths)
            {
                width += i;
            }

            int height = 0;
            foreach(int i in rowHeights)
            {
                height += i;
            }

            pcgLevel = new Level(width, height);

            System.Console.WriteLine(width + " " + height);

            //Step 2. Place each room. There is currently a good bit of duplicate code here from the first step since we need to go through every room to determine the level size then
            //go through each room again to place the room, and this requires a lot of the same information
            foreach (Atom f in roomAtoms)
            {
                //get the information from the room atom again
                int roomNumber = f.getNumericValue(0) - 1; //convert the room number to being zero indexed
                x = f.getNumericValue(1);
                y = f.getNumericValue(2);
                string roomType = f.getValue(3);

                //dimensions of the room
                int roomDimensionX = 0; 
                int roomDimensionY = 0;

                //redetermine the template for the room
                int templateListIndex; //index of the sepcific list of templates to use

                //Redetermine the right list of templates to use
                if (roomType.Equals("boss"))
                {
                    templateListIndex = BOSS_INDEX;
                }

                else if (roomType.Equals("gauntlet"))
                {
                    templateListIndex = GAUNTLET_INDEX;
                }

                else if (roomType.Equals("treasure"))
                {
                    templateListIndex = TREASURE_INDEX;
                }

                else if (roomType.Equals("entrance"))
                {
                    templateListIndex = ENTRANCE_INDEX;
                }

                else //if (roomType.Equals("generic"))
                {
                    templateListIndex = GENERIC_INDEX;
                }

                //get the dimensions of the correct template
                roomDimensionX = allTemplates[templateListIndex][templateIndex[roomNumber]].xDimension;
                roomDimensionY = allTemplates[templateListIndex][templateIndex[roomNumber]].yDimension;

                //determine where the specific row and column (in terms of the inital 10 by 10 grid clingo uses) starts
                int rowStart = 0; //the first y value belonging to the row
                int columnStart = 0; //the first x value belonging to the column

                //add the size of all rows before the current one to get its starting point
                for(int i = 0; i < y; i++)
                {
                    rowStart += rowHeights[i];
                }

                //add the size of all columns before the current one to get its starting point
                for (int i = 0; i < x; i++)
                {
                    columnStart += columnWidths[i];
                }

                //all template sizes are currently only using odd numbers so this room should have a center tile. Determine where that is
                int centerX = columnStart + (int)(columnWidths[x] / 2); //since the widths are odd we can integer divide by 2 then add 1 to get distance to the center. (except the values we need are 0 indexed so the +1 is canceled out)
                int centerY = rowStart + (int)(rowHeights[y] / 2); //since the heights are odd we can integer divide by 2 then add 1 to get distance to the center (except the values we need are 0 indexed so the +1 is canceled out)

                //store the centers
                roomXCenter[roomNumber] = centerX;
                roomYCenter[roomNumber] = centerY;

                //now determine the upper left and bottom right corners of the room (These will be the corners closest to 0,0 (ie have the lowest values) 
                //and farthest from 0,0 (ie have the highest values respectively)
                int lowX = centerX - (int)roomDimensionX / 2;
                int lowY = centerY - (int)roomDimensionY / 2;
                int highX = centerX + (int)roomDimensionX / 2;
                int highY = centerY + (int)roomDimensionY / 2;

                //copy the right template onto the level to set all the tiles correctly
                allTemplates[templateListIndex][templateIndex[roomNumber]].copyToLevel(lowX, lowY, pcgLevel, roomNumber);

                //store information about the room
                pcgLevel.addRoom(lowX, lowY, highX, highY, roomNumber, roomType);
            }

            //Step 3. Add the edges (corridors)
            foreach (Atom f in edgeAtoms) //for each edge/corridor place the corridor and the necessary doors
            {
                //each edge should be between two rooms in the same row/column (in Clingos 10 by 10 grid). Since every room in a column/row is centered around the same index, we can connect
                //two rooms by extending a corridor between their two center points

                //atoms are either uniqueEdge atoms with format uniqueEdge(u,v) denoting an edge between u and v or
                //uniqueLock atoms with format uniqueLock(u,v,kn) denoting an edge between u and v with a lock that needs key kn

                //get the rooms at either end
                int room1 = f.getNumericValue(0) - 1; //convert the room number to being zero indexed
                int room2 = f.getNumericValue(1) - 1; //convert the room number to being zero indexed

                int keyNumber = -1; //if the corridor is locked which number key opens it or -1 if the corridor is not locked

                if (f.getAtomName().Equals("uniqueLock")) //check if the atom indicates there is a lock and if so get the number of the key that opens it
                {
                    keyNumber = f.getNumericValue(2);
                }

                //keep track of whether each of the two doors we need to place have been placed already
                bool door1Placed = false;
                bool door2Placed = false;
                int prevX = 0; // track the previous tile checked for use in placing doors correctly
                int prevY = 0; 

                //the corridor can be either vertical or horizontal, and in each case its possible for either room1 or room2 to be the top/left room
                //So determine the start and end points of the corridors with the corridor starting at the lower corrodinates and ending at at higher oneces
                int lowX, highX, lowY, highY;

                if(roomXCenter[room1] < roomXCenter[room2])
                {
                    lowX = roomXCenter[room1];
                    highX = roomXCenter[room2];
                }

                else
                {
                    lowX = roomXCenter[room2];
                    highX = roomXCenter[room1];
                }

                if (roomYCenter[room1] < roomYCenter[room2])
                {
                    lowY = roomYCenter[room1];
                    highY = roomYCenter[room2];
                }

                else
                {
                    lowY = roomYCenter[room2];
                    highY = roomYCenter[room1];
                }

                //finally for each tile in the line between the two room centers
                //one of these two loops won't do anything because the centers are aligned in one aspect, but its easier to have two loops then check which way the corridor runs and write seperate code
                //for each case. 
                for (int i = lowX; i <= highX; i++)
                {
                    for (int j = lowY; j <= highY; j++)
                    {
                            //decide what to do with the current tile. In general we should be running into tiles that have been set to something while we are still within the first room,
                            //then run into undefined tiles once we reach the part of the level between the two rooms, and finally hit tiles with a definition once we enter the second room
                          
                            if (!door1Placed && pcgLevel.getTileType(i, j) == TileType.undefined) //the first door is placed as soon as we hit an undefined tile (ie leave the current room), so
                                                                                                  //don't do anything till we hit the first undefined tile and place that room once we do
                            {
                                if (keyNumber != -1) //if the corridor is locked add a locked door
                                {
                                    pcgLevel.setTileType(i, j, TileType.locked);
                                    pcgLevel.setTileAdditionalInformation(i, j, keyNumber); //mark the number of the keys

                                    pcgLevel.levelMap[i, j].RoomNumber = keyNumber; //as a quick hack to make the key number visible set the room
                                    //number to the key number which as part of a previous hack is displayed on the map
                                }

                                else //otherwise the corridor is not locked add a regular door
                                {
                                    pcgLevel.setTileType(i, j, TileType.door);
                                }

                                door1Placed = true; //mark that we have placed the first door
                            }

                            else if(door1Placed && !door2Placed) //once the first door is placed we can start placing the corridor until we place the second door where the corridor ends
                            {
                                if (!door2Placed && pcgLevel.getTileType(i, j) != TileType.undefined) //Check for the first tile that is already defined, which means that we've hit the second room.                                                                    
                                {
                                    //place a door one tile back (which should be the last undefined tile)

                                    if (keyNumber != -1) //if the corridor is locked place a locked door
                                    {
                                        pcgLevel.setTileType(prevX, prevY, TileType.locked);
                                        pcgLevel.setTileAdditionalInformation(prevX, prevY, keyNumber); //mark the number of the keys

                                        pcgLevel.levelMap[prevX, prevY].RoomNumber = keyNumber; //as a quick hack to make the key number visible set the room
                                                                                                //number to the key number which as part of a previous hack is displayed on the map
                                    }

                                    else //otherwise the corridor is not locked so place a regular door
                                    {
                                        pcgLevel.setTileType(prevX, prevY, TileType.door);
                                    }

                                    door2Placed = true; //mark that we have placed the second door

                                }

                                else //otherwise we have not reache the end of the corridor so place a floor tile
                                {
                                    pcgLevel.setTileType(i, j, TileType.floor);
                                }
                            }
                        
                        //keep track of where we just were for use in placing the second door later
                        prevX = i;
                        prevY = j;
                    }
                }
            }

            //Step 4. Mark where keys
            //right now this is mostly to easily see where the  keys are. The actual method of displaying this is not final, nor is the fact that every
            //key is placed in the center of the room
            foreach (Atom f in keyAtoms)
            {
                //the atoms we should be reading in from the list are keyRoom atoms which have the format keyRoom(ID,KN) where ID is the room number
                //and KN is the number of the key in said room

                int room = f.getNumericValue(0) - 1; //get the room number and convert it to being zero indexed
                int key = f.getNumericValue(1); //get the key number

                //add the key to the center of the room
                pcgLevel.setTileType(roomXCenter[room], roomYCenter[room], TileType.key);
                pcgLevel.setTileAdditionalInformation(roomXCenter[room], roomYCenter[room], key); //store the number of the key

                //as a temporary measure set the room number of the tile to the key number so the number is displayed on the map
                pcgLevel.levelMap[roomXCenter[room], roomYCenter[room]].RoomNumber = key;
            }

            pcgLevel.finalizeLevel();
        }

        
        //setters and getters
        public Level getLevel()
        {
            return pcgLevel;
        }

    }

    
}


%counts syntax changed
%Changes. Hide doesn't work. Need to instead use show I believe
%Can't have multiple :'s inside {} replace all but the first with ,

%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------


areaSizeRange(minAreaSize..maxAreaSize). %range of possible area length/widths
floorSizeRange(1 .. (maxAreaSize - 2)). %range of valid floor positions
roomSizeRange(minLength .. maxLength).
%rectRange(0 .. maxRects).

%----------------------------------------------------------------------------
%Level Basics
%----------------------------------------------------------------------------

%determine the size of the area
1 { levelLengthX(X) : areaSizeRange(X) } 1. 
1 { levelLengthY(Y) : areaSizeRange(Y) } 1.

%determine valid tile numbers
lengthXDim(0..(X - 1)) :- levelLengthX(X).
lengthYDim(0..(Y - 1)) :- levelLengthY(Y).

%define tiles
%tile(X,Y) :- lengthXDim(X), lengthYDim(Y), level(L).

%------------------------------------------------------------------------------------------
%Reachable tiles
%------------------------------------------------------------------------------------------

step(0,-1 ;; 0,1 ;; 1,0 ;; -1,0). 

%-----------------------------------------------------------------------
% Indoor level Specific Elements
%------------------------------------------------------------------------

%A room (defined by the top left (XUL,YUL) and Bottom Right (XBR, YBR) corners
minRooms { room(XUL, YUL, LENGTH, HEIGHT) : floorSizeRange(XUL) , floorSizeRange(YUL) , roomSizeRange(LENGTH) , roomSizeRange(HEIGHT)} maxRooms.

corType(corX).
corType(corY).

minCor { corridor(X,Y,LENGTH, T) : floorSizeRange(X), roomSizeRange(LENGTH), floorSizeRange(Y), corType(T) } maxCor.

#show corridor/4.

corridorX(X, LENGTH, Y) :- corridor(X,Y,LENGTH,corX).

corridorY(Y, LENGTH, X) :- corridor(X,Y,LENGTH,corY).

%Rectangle covers shared rules for corriders and rooms
rectangle(XUL, YUL, (XUL + LENGTH - 1), (YUL + HEIGHT - 1), room) :- room(XUL, YUL, LENGTH, HEIGHT).
rectangle(XL, Y, (XL + LENGTH - 1), Y,corX)  :- corridorX(XL, LENGTH, Y).
rectangle(X, YU, X, (YU + LENGTH - 1),corY)  :- corridorY(YU, LENGTH, X).

:- rectangle(XUL, YUL, XBR, YBR,_), levelLengthX(X), XBR >= X - 1.
:- rectangle(XUL, YUL, XBR, YBR,_), levelLengthY(Y), YBR >= Y - 1.

floorType(X,Y,T) :- rectangle(XUL, YUL, XBR, YBR, T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor
floor(X,Y) :- floorType(X,Y,T). %seperate atom for when we need need a floor and the type of room it's from doesn't matter
corFloor(X,Y) :- floorType(X,Y,corX). %seperate atom for when we need a floor from a corridor
corFloor(X,Y) :- floorType(X,Y,corY). %seperate atom for when we need a floor from a corridor

%collision detection hack for each tile remember seperatly the 4 corners of the rectangle of the room it's from, if any tile has two of those registered there is a collision
floorXUL(X,Y,XUL,T) :- rectangle(XUL, YUL, XBR, YBR,T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor
floorYUL(X,Y,YUL,T) :- rectangle(XUL, YUL, XBR, YBR,T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor

:- rectangle(XUL, YUL, XBR1, _,_), rectangle(XUL, YUL, XBR2, _,_), XBR1 != XBR2.
:- rectangle(XUL, YUL, _, YBR1,_), rectangle(XUL, YUL, _, YBR2, _), YBR1 != YBR2.
:- rectangle(XUL, YUL, _, _,T1), rectangle(XUL, YUL, _, _, T2), T1 != T2.

overLap(X,Y,T1,T2) :- floorXUL(X,Y,XUL1,T1), floorXUL(X,Y,XUL2,T2), XUL1 != XUL2.
overLap(X,Y,T1,T2) :- floorYUL(X,Y,YUL1,T1), floorYUL(X,Y,YUL2,T2), YUL1 != YUL2.

%What happens when rooms share the upper corner

%wallX(X,Y) from X,Y to X+1,Y. The rightmost x is not a valid x for a wall on the x axis it can only be used for walls on the y Axis

%there should be no overlap for rooms, and no overlap between two corridors along the same axis
:- overLap(X,Y,T1,T2), T1 = room. 
:- overLap(X,Y,T1,T2), T2 = room.
:- overLap(X,Y,T1,T2), T1 = T2.

:- overLap(X1,Y1,corX,corY), overLap(X2,Y2,corX,corY), X1 < X2, (X2 - X1) <= 2.
:- overLap(X1,Y1,corX,corY), overLap(X2,Y2,corX,corY), Y1 < Y2, (Y2 - Y1) <= 2.

%determine tiles that could be part of wall around a room
roomWall(XW,(YUL-1)) :- rectangle(XUL, YUL, XBR, YBR,_), lengthXDim(XW), XW >= XUL - 1, XW <= XBR + 1. %add walls on top of the room
roomWall(XW,(YBR + 1)) :- rectangle(XUL, YUL, XBR, YBR,_), lengthXDim(XW), XW >= XUL - 1, XW <= XBR + 1. %add walls on bottom of the room
roomWall((XUL-1),YW) :- rectangle(XUL, YUL, XBR, YBR,_), lengthYDim(YW), YW >= YUL - 1, YW <= YBR + 1. %add walls on left of the room
roomWall((XBR + 1),YW) :- rectangle(XUL, YUL, XBR, YBR,_), lengthYDim(YW), YW >= YUL - 1, YW <= YBR + 1. %add walls on left of the room

%add a small number of doors to the walls
0 { door(XW,(YUL-1)) : lengthXDim(XW), XW >= XUL - 1, XW <= XBR + 1} 2 :- rectangle(XUL, YUL, XBR, YBR,_). %add walls on top of the room
0 { door(XW,(YBR + 1)) : lengthXDim(XW), XW >= XUL - 1, XW <= XBR + 1} 2 :- rectangle(XUL, YUL, XBR, YBR,_). %add walls on top of the room
0 { door((XUL-1),YW) : lengthYDim(YW), YW >= YUL - 1, YW <= YBR + 1} 2 :- rectangle(XUL, YUL, XBR, YBR,_). %add walls on top of the room
0 { door((XBR+1),YW) : lengthYDim(YW), YW >= YUL - 1, YW <= YBR + 1} 2 :- rectangle(XUL, YUL, XBR, YBR,_). %add walls on top of the room

:- floor(X,Y), wall(X,Y). %walls and floors can't overlap
:- floor(X,Y), door(X,Y).

%Add condition that wall is not adjacrent to an overlap or ontop of a door
wall(X,Y) :- roomWall(X,Y), not overLap(X-1,Y,corX,corY), not overLap(X+1,Y,corX,corY), not overLap(X,Y-1,corX,corY), not overLap(X,Y+1,corX,corY), not door(X,Y).
				
% %add special cases for tbranches
% barricadeX(X,Y) :- roomBarricadeX(X,Y), overLap(X,Y,corX,corY), floorType(X,Y-1,room).   %Condition   R  (R = room, O = overlap)
																						               % %           ---
																						               % %            O
% barricadeX(X,Y) :- roomBarricadeX(X,Y), overLap(X,Y-1,corX,corY), floorType(X,Y,room).   %Condition   O  (R = room, O = overlap)
																						               % %           ---
																						               % %            R
% barricadeY(X,Y) :- roomBarricadeY(X,Y), overLap(X,Y,corX,corY), floorType(X-1,Y,room).   %Condition   R|O  (R = room, O = overlap)

% barricadeY(X,Y) :- roomBarricadeY(X,Y), overLap(X-1,Y,corX,corY), floorType(X,Y,room).   %Condition   O|R  (R = room, O = overlap)			
				
%two doors can't be adjacent to one another
:- door(X,Y), door(X2,Y2), step(DX,DY), X2 = X + DX, Y2 = Y + DY.			
				
%a door must be between two floor tiles
doorOk(X,Y) :- door(X,Y), floor(X-1,Y), floor(X+1,Y).
doorOk(X,Y) :- door(X,Y), floor(X,Y-1), floor(X,Y+1).				
:- door(X,Y), not doorOk(X,Y).				
			
		
%TODO. Finish debugging

%TODO. add constraint, both ends of a corridor must be an overlap/have a door to a adjacent 

%define spaces that are the ends of cooridors
corEnd(XUL, YUL) :- rectangle(XUL, YUL, XBR, YBR, corX).
corEnd(XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, corX).
corEnd(XUL, YUL) :- rectangle(XUL, YUL, XBR, YBR, corY).
corEnd(XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, corY).

%check if there is a connection to a room in all 4 directions
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL-1,YUL), door(XUL-1,YUL), connection(XUL-1,YUL,XUL-2,YUL),  floorType(XUL-2,YUL,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL+1,YUL), door(XUL+1,YUL), connection(XUL+1,YUL,XUL+2,YUL),  floorType(XUL+2,YUL,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL,YUL-1), door(XUL,YUL-1), connection(XUL,YUL-1,XUL,YUL-2),  floorType(XUL,YUL-2,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL,YUL+1), door(XUL,YUL+1), connection(XUL,YUL+1,XUL,YUL+2),  floorType(XUL,YUL+2,room).

%every end of a corridor must be connected to a room or overlapping another corridor
:- corEnd(XBR, YBR), not corEndConnectedRoom(XBR, YBR), not overLap(XBR, YBR,_,_).
%corridors shouldn't be parallel and adjacent. (Allow this though if the adjacent spaces are both edges of corridors, could create some intresting shapes)
%:- floorType(X,Y,corX), floorType(X,Y-1,corX), not corEnd(X,Y).
%:- floorType(X,Y,corY), floorType(X-1,Y,corY), not corEnd(X,Y).
%:- floorType(X,Y,corX), floorType(X,Y-1,corX), not corEnd(X,Y-1).
%:- floorType(X,Y,corY), floorType(X-1,Y,corY), not corEnd(X-1,Y).

%corridors should connect two or more rooms, or have 1 end be an overlap. To save memory only check connections at the ends. These is still moderatly memory intensive

%for each end of the corridor corridor, find all connected tiles that are in a room and store the upper left corner of that room (Since rooms can't overlap, that corner will be unique)
connectToRoomXUL(X,Y,XUL) :- corEnd(X,Y), door(X2,Y2), floorXUL(X3,Y3,XUL,room), step(DX,DY), X2 = X + DX, Y2 = Y + DY, X3 = X2 + DX, Y3 = Y2 + DY.
connectToRoomYUL(X,Y,YUL) :- connectToRoomXUL(X,Y,XUL), floorXUL(X,Y,XUL,room), floorYUL(X,Y,YUL,room).

%check both ends of corridor to see if room differs in x coordinate of upper left corner
connectsTwoRooms(XUL, YUL, XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, T), connectToRoomXUL(XUL, YUL, N1) , connectToRoomXUL(XBR, XBR, N2) , N1 != N2, T != room, N1 != XUL, N2 != XUL.

%check both ends of corridor to see if room differs in y coordinate of upper left corner
connectsTwoRooms(XUL, YUL, XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, T), connectToRoomYUL(XUL, YUL, N1) , connectToRoomYUL(XBR, XBR, N2) , N1 != N2, T != room, N1 != YUL, N2 != YUL.

%A corridor must bec connected to at least two rooms
:- rectangle(XUL, YUL, XBR, YBR, corX), not connectsTwoRooms(XUL, YUL, XBR, YBR), not overLap(XUL,YUL,corX,corY), not overLap(XBR,YBR,corX,corY).
:- rectangle(XUL, YUL, XBR, YBR, corY), not connectsTwoRooms(XUL, YUL, XBR, YBR), not overLap(XUL,YUL,corX,corY), not overLap(XBR,YBR,corX,corY).

%A door is not ok if there is another door in a parallel line (either along the x or y axis) that connects the same two rooms
% doorNotOkay(X1,Y) :- door(X1,Y), door(X2,Y), edgeFloorID(X1,Y-1,ID1), edgeFloorID(X2,Y-1,ID1), edgeFloorID(X1,Y+1,ID2), edgeFloorID(X2,Y+1,ID2), X2 > X1.
% doorNotOkay(X,Y1) :- door(X,Y1), door(X,Y2), edgeFloorID(X-1,Y1,ID1), edgeFloorID(X-1,Y2,ID1), edgeFloorID(X+1,Y1,ID2), edgeFloorID(X+1,Y2,ID2), Y2 > Y1.
% :- doorNotOkay(X,Y).

%doorYOkay(X,Y1) :- doorY(X,Y1), doorY(X,Y2), wallX(X2,Y3), Y1 < Y2, Y3 > Y1, Y3 < Y2, X2 <= X, X2 >= X-1.
%:- doorY(X,Y1), doorY(X,Y2), Y1 < Y2, not doorYOkay(X,Y1).

%a corridor must have at least one space that ia adjacent to 2 blocked tile
%corridorXOkay(XUL,Y) :- rectangle(XUL,Y,XBR,Y,corX), floor(X,Y), X >= XUL, X <= XBR, not floor(X,Y - 1), not floor(X,Y + 1).
%:- rectangle(XUL,Y,_,_,corX), not corridorXOkay(XUL,Y).

%corridorYOkay(X,YUL) :- rectangle(X,YUL,X,YBR,corY), floor(X,Y), Y >= YUL, Y <= YBR, not floor(X - 1,Y), not floor(X + 1, Y).
%:- rectangle(X,YUL,_,_,corY), not corridorYOkay(X,YUL).

%----------------------------------------------------------------------------------

edgeFloorType(X,Y,T) :- rectangle(X, YUL, _, YBR, T),  Y >= YUL, Y <= YBR, lengthYDim(Y). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(_, YUL, X , YBR, T),  Y >= YUL, Y <= YBR, lengthYDim(Y). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(XUL, Y, XBR, _ , T),  X >= XUL, X <= XBR, lengthXDim(X). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(XUL, _, XBR, Y , T),  X >= XUL, X <= XBR, lengthXDim(X). %all tiles in the room must be floor

%2.0GB to add reachable constraints for 16x16. Better then I've gotten but not good enough
%Adding Key to 2.3 GB

rectRange(1..maxRects). %when this is changed to a constant need to change gui code

1 { roomID(XUL,YUL,I) : lengthXDim(XUL), lengthYDim(YUL), rectRange(I) } 1 :- rectangle(XUL,YUL,_,_,_).
:- roomID(XUL1,_,I), roomID(XUL2,_,I), XUL1 != XUL2.
:- roomID(_,YUL1,I), roomID(_,YUL2,I), YUL1 != YUL2.

%TODO: See if using this construct elsewhere is faster
edgeFloorID(XUL,YUL .. YBR,ID) :- rectangle(XUL, YUL, _, YBR, _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(X,YUL .. YBR,ID) :- rectangle(XUL, YUL, X , YBR, _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(XUL .. XBR,YUL,ID) :- rectangle(XUL, YUL, XBR, _ , _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(XUL .. XBR,Y,ID) :- rectangle(XUL, YUL, XBR, Y , _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor

edgeFloor(X,Y) :- edgeFloorID(X,Y,_).


connectedRooms(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connection(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.
connectedRooms(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), door(X2,Y2), edgeFloorID(X3,Y3,ID2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY, X3 = X2 + DX, Y3 = Y2 + DY.

connectedRooms(ID2,ID1) :- connectedRooms(ID1,ID2).

#show connectedRooms/2.

passable(X,Y) :- floor(X,Y).
passable(X,Y) :- door(X,Y).

% %define what tiles are connected to what tiles
connection(X1,Y1,X2,Y2) :- passable(X1,Y1), passable(X2,Y2), X1 == X2, (Y1 - 1) == Y2.
% %connection(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 + 1) == Y2, not wallX(X2,Y2).
connection(X1,Y1,X2,Y2) :- passable(X1,Y1), passable(X2,Y2), Y1 == Y2, (X1 - 1) == X2.
% %connection(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 + 1) == X2, not wallY(X2,Y2).



connection(X2,Y2,X1,Y1) :- connection(X1,Y1,X2,Y2).

%1 { levelStartRoom(ID) : roomID(_,_,ID) } 1.

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room

reachable(ID2) :- reachable(ID1), connectedRooms(ID1,ID2), finalRoom(IDF), ID1 != IDF.
:- roomID(_,_,ID), not reachable(ID).

reachableWithoutX(START,X) :- levelStartRoom(START), roomID(_,_,X).
reachableWithoutX(ID2,X) :- reachableWithoutX(ID1,X), connectedRooms(ID1,ID2), ID1 != X.

#show reachableWithoutX/2.

%Define a room as being  the end of the level
1 { finalRoom(ID) : roomID(_,_,ID) } 1.

#show finalRoom/1.


% % Distance rules
% roomCenter(ID,XC,YC) :- roomID(XUL,YUL,ID), rectangle(XUL,YUL,XBR,YBR,_), XC = (XUL + ((XBR - XUL) / 2)), YC = (YUL + ((YBR - YUL) / 2)).
% % clingo 4 seems to have no absolute value so I need to improvise here
% manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X1 - X2) + (Y1 - Y2), X1 >= X2, Y1 >= Y2.
% manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X2 - X1) + (Y1 - Y2), X2 > X1, Y1 >= Y2.
% manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X1 - X2) + (Y2 - Y1), X1 >= X2, Y2 > Y1.
% manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X2 - X1) + (Y2 - Y1), X2 > X1, Y2 > Y1.

% Key code

% connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1), not lockedDoorX(X1,Y1).
% connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).

% connectionNoKey(X2,Y2,X1,Y1) :- connectionNoKey(X1,Y1,X2,Y2).

% connectedRoomsNoKey(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connectionNoKey(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


% reachableNoKey(ID2) :- reachableNoKey(ID1), connectedRoomsNoKey(ID1,ID2).

% 1 { lockedDoorX(X,Y) : doorX(X,Y) } 1.
% 1 { keyRoom(ID) : roomID(_,_,ID) } 1.

% :- keyRoom(ID1), levelStartRoom(ID2), ID1 == ID2. %make sure key isn't in the starting room.

% :- keyRoom(ID), not reachableNoKey(ID).
% :- 0 { roomID(_,_,ID) : not reachableNoKey(ID) } 1.

% #show connectedRoomsNoKey/2.
% #show reachable/1.
% #show reachableNoKey/1.
% #show lockedDoorX/2.
% #show keyRoom/1.

% Final framework details for flow

% the start and end rooms must be unique
:- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
%:- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.

roomIDExists(ID) :- roomID(_,_,ID). %a quick way to check if a certain ID number is used. Mainly this allows us to specify attributes of a room that needs to exist by an ID number and then have
									 % an integrity constraint using this atom that says a room with that ID must exist.

%NOTE. The one thing I did not have in previous tests was the 3 rooms you have to pass through to get to the end room. That apparently adds a lot of time									 
									
% #show connection/4.
% #show edgeFloor/2.
%#show levelStart/2. 
% #show levelStartRoom/1.
% #show edgeFloorID/3.
#show roomID/3.
%#show connectedRooms/2.
% #show reachable/1.
% #show roomIDExists/1.


roomType(empty).
roomType(treasure).
roomType(arena).

1 { typeOfRoom(ID,T) : roomType(T) } 1 :- rectangle(XUL,YUL,_,_,room), roomID(XUL,YUL,ID).

:- typeOfRoom(ID,T1), typeOfRoom(ID,T2), T1 != T2.

:- typeOfRoom(ID1,treasure), 3 {connectedRooms(ID1,ID2) }.
:- levelStartRoom(ID), typeOfRoom(ID,treasure).
:- finalRoom(ID), typeOfRoom(ID,treasure).
%:- 0 { typeOfRoom(ID,treasure) : rectRange(ID) } 0. %try replacing this which a constraint that a room exists that is a treasure room (Also need constraint a room can't have two types)

%1 { chest(X,Y) : edgeFloorID(X,Y,ID) } 4 :- typeOfRoom(ID,treasure), rectangle(XUL,YUL,XBR,YBR,room), roomID(XUL,YUL,ID).

%#show typeOfRoom/2.
%#show chest/2.

%#show corOffRoom/2.
%#show corridor/4.

%-----------------------------------------
%Hidden elements
%------------------------------------
#show floor/2.
#show door/2.
%#show wall/2.
#show levelLengthX/1.
#show levelLengthY/1.
#show rectangle/5.
%#show overLap/4.
%#show room/4.
%#show connectsTwoRooms/5.
%#show corConnectsToRoomXUL/7.
%#show corConnectsToRoomYUL/7.
%#hide lengthXDim/2.
%#hide lengthYDim/2.
%#hide tile/3.
%#hide connectedUp/5.
%#hide connectedDown/5.
%#hide connectedRight/5.
%#hide connectedLeft/5.
%#hide connection/5.
%#hide wallSizeRange/1.
%#hide floorSizeRange/1.
%#hide wallXDim/2.
%#hide wallYDim/2.
%#hide barricadeX/3.
%#hide barricadeY/3.
%#hide nonEdgeXDim/2.
%#hide targetIndexRange/1.
%#hide nonEdgeXDim/2.
%#hide nonEdgeYDim/2.
%#hide npcNumRange/1.
%#hide questNumRange/1.
%#hide stageRange/1.
%#hide reachable/3.
%#hide levelNumRange/1.

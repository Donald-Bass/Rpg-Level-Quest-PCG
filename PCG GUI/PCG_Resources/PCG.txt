%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

%Determine the number of rooms 
numRoomRange(10 .. 10). %set a minimum and maximum number of rooms
1 { numRooms(X) : numRoomRange(X) } 1.

%Each room number corrosponds to a room
room(1 .. X) :- numRooms(X). 

1 { edge(X,Y) : room(Y), X != Y } 5 :- room(X).

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could violate the max number of edges out of a room
:- edge(X,Y), not edge(Y,X). 

edgeNumber(N) :- N = #count{ X,Y : edge(X,Y) }.

%in a planar graph e < 3v-6 (also remember edgeNumber is 2e)
:- edgeNumber(E), numRooms(V), (E / 2) >= ((3 * V) - 6).

%if there isn't a 3 cycle then e < 2v-4
threeCycle :- room(A), room(B), room(C), edge(A,B), edge(B,C), edge(C,A).
:- not threeCycle, edgeNumber(E), numRooms(V), (E / 2) >= ((2 * V) - 4).



1 { levelStartRoom(ID) : room(ID) } 1.

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room
reachable(ID2) :- reachable(ID1), edge(ID1,ID2), finalRoom(IDF), ID1 != IDF.
:- room(ID), not reachable(ID).

reachableWithoutX(START,X) :- levelStartRoom(START), room(X).
reachableWithoutX(ID2,X) :- reachableWithoutX(ID1,X), edge(ID1,ID2), ID1 != X, finalRoom(IDF), ID1 != IDF.

%reachableWithoutXY(START,X,Y) :- levelStartRoom(START), room(X), room(Y).
%reachableWithoutXY(ID2,X,Y) :- reachableWithoutXY(ID1,X,Y), edge(ID1,ID2), ID1 != X, ID1 != Y, finalRoom(IDF), ID1 != IDF.

% % Define a room as being  the end of the level
1 { finalRoom(ID) : room(ID) } 1.

% the start and end rooms must be unique
:- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
:- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.
:- finalRoom(ID), levelStartRoom(ID).

#show edgeNumber/1.
#show numRooms/1.
#show edge/2.
#show room/1.
#show threeCycle/0.

% #show finalRoom/1.


% % Key code

% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1), not lockedDoorX(X1,Y1).
% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).

% % connectionNoKey(X2,Y2,X1,Y1) :- connectionNoKey(X1,Y1,X2,Y2).

% % connectedRoomsNoKey(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connectionNoKey(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


% % reachableNoKey(ID2) :- reachableNoKey(ID1), connectedRoomsNoKey(ID1,ID2).

% % 1 { lockedDoorX(X,Y) : doorX(X,Y) } 1.
% % 1 { keyRoom(ID) : roomID(_,_,ID) } 1.

% % :- keyRoom(ID1), levelStartRoom(ID2), ID1 == ID2. %make sure key isn't in the starting room.

% % :- keyRoom(ID), not reachableNoKey(ID).
% % :- 0 { roomID(_,_,ID) : not reachableNoKey(ID) } 1.

% % #show connectedRoomsNoKey/2.
% % #show reachable/1.
% % #show reachableNoKey/1.
% % #show lockedDoorX/2.
% % #show keyRoom/1.

% % Final framework details for flow

% % the start and end rooms must be unique
% :- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
% % :- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.

% roomType(empty).
% roomType(treasure).
% roomType(arena).

% 1 { typeOfRoom(ID,T) : roomType(T) } 1 :- rectangle(XUL,YUL,_,_,room), roomID(XUL,YUL,ID).

% :- typeOfRoom(ID,T1), typeOfRoom(ID,T2), T1 != T2.

% :- typeOfRoom(ID1,treasure), 3 {connectedRooms(ID1,ID2) }.
% :- levelStartRoom(ID), typeOfRoom(ID,treasure).
% :- finalRoom(ID), typeOfRoom(ID,treasure).
% % :- 0 { typeOfRoom(ID,treasure) : rectRange(ID) } 0. %try replacing this which a constraint that a room exists that is a treasure room (Also need constraint a room can't have two types)
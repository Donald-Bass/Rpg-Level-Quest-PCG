%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

xRange(0..9).
yRange(0..9).

%valid room types
%roomType(entrance).
%roomType(boss).
%roomType(gauntlet).
%roomType(treasure).
%roomType(generic).

%Determine the number of rooms 
numRoomRange(minRooms .. maxRooms). %set a minimum and maximum number of rooms
1 { numRooms(X) : numRoomRange(X) } 1.

roomRange(1 .. X) :- numRooms(X).

%Each room number corrosponds to a room, which has coordinates and a type
1 { room(N,X,Y,T) : xRange(X), yRange(Y) } 1 :- roomRange(N), typeOfRoom(N,T). 

:- room(N1,X,Y,_), room(N2,X,Y,_), N1 != N2. %two rooms cannot share the same place

%for the sake of testing at the moment no two rooms may be adjacent
:- room(N1,X1,Y,_), room(N2,X2,Y,_), N1 != N2, X2 - 1 = X1.
:- room(N1,X,Y1,_), room(N2,X,Y2,_), N1 != N2, Y2 - 1 = Y1.

0 { basicEdge(X,Y) : room(Y,_,_,_), X != Y } 4 :- room(X,_,_,_).

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could violate the max number of edges out of a room
:- basicEdge(X,Y), not basicEdge(Y,X). 

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room
reachable(ID2) :- reachable(ID1), edge(ID1,ID2). %, finalRoom(IDF), ID1 != IDF.
:- room(ID,_,_,_), not reachable(ID).

%define number of connections
numConnections(ID,N) :- N = #count{ V : edge(ID,V) } , room(ID,_,_,_).
%:- numberOfEdges(ID,C), numConnections(ID,N), C != N. %if a room has a set number of connections enforce that number

%define what it means for a room to come before
%really there are two different definitions we could use here. xBeforeY says you have to visit room x before you can visit room Y. xOptionalBeforeY says you can visit x without visiting y, but you don't have to visit x to visit 

reachableWithoutRooms(START,FB1) :- levelStartRoom(START), room(FB1,_,_,_). %The start room can be reached without passing through a specific room no matter what that room is
reachableWithoutRooms(ID2,FB1) :- reachableWithoutRooms(ID1,FB1), edge(ID1,ID2), ID1 != FB1. %otherwise a room can be reached without going through another room, if there is a room the first is adjacent to that can be reached without going through said room

mustVisitXtoReachY(X,Y) :- room(X,_,_,_), room(Y,_,_,_), not reachableWithoutRooms(Y,X). %Now we reverse the results to find which rooms can't be reached without passing through particular rooms which is the form we actually need

																						 
mustVisitXtoReachY(X,Z)	:-	mustVisitXtoReachY(X,Y), mustVisitXtoReachY(Y,Z). %this property should be transative. If you must visit room X to visit Y and Y to visit Z logically you must visit X to reach Z
						
:- xBeforeY(X,Y), not mustVisitXtoReachY(X,Y). %a room doesn't come before another one unless you can access the first without going through the second.

horEdge(U,V) :- basicEdge(U,V), U < V, room(U, X1, Y,_), room(V, X2, Y,_). 
vertEdge(U,V) :- basicEdge(U,V), U < V, room(U, X, Y1,_), room(V, X, Y2,_). 

:- basicEdge(U,V), U < V, not horEdge(U,V), not vertEdge(U,V).

%Make sure distances between rooms aren't too far. (A really long corridor isn't great gameplay)
:- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X1 < X2, D = X2 - X1, D > 4.
:- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X2 < X1, D = X1 - X2, D > 4.
:- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y1 < Y2, D = Y2 - Y1, D > 4.
:- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y2 < Y1, D = Y1 - Y2, D > 4.

% horDist(U,V,D) :- D = @lAbs(X1 - X2), horEdge(U,V), room(U,X1,Y), room(V,X2,Y). %For horizontal lines the distance is the absolute value of the difference between x components
% edgeDist(U,V,D) :- horDist(U,V,D). %store the distance in a final atom that holds a distance for any type of edge
% vertDist(U,V,D) :- D = @lAbs(Y1 - Y2), vertEdge(U,V), room(U,X,Y1), room(V,X,Y2).  %For vertical lines the distance is the absolute value of the difference between y components
% edgeDist(U,V,D) :- vertDist(U,V,D).
% :- edgeDist(_,_,D), D > 3.


%there can be no vertices in the middle of an edge
% :- horEdge(U,V), room(U,X1,Y), room(V,X2,Y), room(_,X3,Y), X1 < X2, X3 > X1, X3 < X2.
% :- horEdge(U,V), room(U,X2,Y), room(V,X1,Y), room(_,X3,Y), X1 < X2, X3 > X1, X3 < X2.

% :- vertEdge(U,V), room(U,X,Y1), room(V,X,Y2), room(_,X,Y3), Y1 < Y2, Y3 > Y1, Y3 < Y2.
% :- vertEdge(U,V), room(U,X,Y2), room(V,X,Y1), room(_,X,Y3), Y1 < Y2, Y3 > Y1, Y3 < Y2.

%One more try

occupied(X3,Y,U,V) :- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X1 < X2, xRange(X3), X3 > X1, X3 < X2.
occupied(X3,Y,U,V) :- horEdge(U,V), room(U,X2,Y,_), room(V,X1,Y,_), X1 < X2, xRange(X3), X3 > X1, X3 < X2.
occupied(X,Y3,U,V) :- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y1 < Y2, yRange(Y3), Y3 > Y1, Y3 < Y2.
occupied(X,Y3,U,V) :- vertEdge(U,V), room(U,X,Y2,_), room(V,X,Y1,_), Y1 < Y2, yRange(Y3), Y3 > Y1, Y3 < Y2.

:- occupied(X,Y,_,_), room(_,X,Y,_).
:- occupied(X,Y,U1,_), occupied(X,Y,U2,_), U1 != U2.
:- occupied(X,Y,_,V1), occupied(X,Y,_,V2), V1 != V2.

edge(U,V) :- horEdge(U,V).
edge(U,V) :- vertEdge(U,V).
edge(V,U) :- edge(U,V).

uniqueEdge(U,V) :- edge(U,V), U < V. %Create a version of the edge atom that only has each edge once

%key code

#const minKeys = 1.
#const maxKeys = 3.
possibleNumKeysRange(minKeys .. maxKeys).

1 {numKeys(N) : possibleNumKeysRange(N) } 1. %determine the number of keys in the level within the accepted ranged of course 
keyRange(1..X) :- numKeys(X).

% keyRoom(2,1).
% keyRoom(5,2).

% lock(1,3,1).
% lock(4,6,2).

1 { keyRoom(RN,KN) : room(RN,_,_,_) } 1 :- keyRange(KN). %the key KN is in room RN
1 { preLock(X,Y,KN) : edge(X,Y) } 1  :- keyRange(KN). %the lock KN opens is edge X,Y

%for some inexplicable reason using lock instead of preLock in the previous statement prevents the program from being satisifed.
lock(X,Y,KN) :- preLock(X,Y,KN).

lock(Y,X,KN) :- lock(X,Y,KN). %locks exist in both directions

%Some more sanity checks
:- keyRoom(RN,KN), lock(RN,RN2,KN). %A key should not be in the same room the locked corridor is
:- keyRoom(RN,KN), lock(RN2,_,KN), not reachableWithoutRooms(RN2, RN). %There is no point in having a key in a room if the only way to reach one of the rooms around the lock is through the key room in the first place

%To simplify each room can only contain one key and each edge only 1 lock
:- keyRoom(RN,KN1), keyRoom(RN,KN2), KN1 != KN2.
:- lock(X,Y,KN1), lock(X,Y,KN2), KN1 != KN2.


%determine which rooms can be reached without each key
reachableWithoutKey(ID,KN) :- keyRange(KN), levelStartRoom(ID).
reachableWithoutKey(ID2,KN) :- reachableWithoutKey(ID1,KN), edge(ID1,ID2), not lock(ID1,ID2,KN).

:- keyRoom(RN,KN), not reachableWithoutKey(RN,KN). %a key cannot be stuck behind the lock it opens

roomsBlocked(KN) :- keyRange(KN), room(RN,_,_,_), not reachableWithoutKey(RN,KN). %check if any rooms are actually blocked off by the lock
:- keyRange(KN), not roomsBlocked(KN). %for now force each lock to actually lock something away.

%Ok now the trickest part. In a series of stages we need to make sure all the rooms can enventually be reached by collecting the keys in a proper order
%The first stage we have no keys collected and find all the keys we can collect without any keys. The second stage we find all the additional keys we can collect with those keys collected in the previous stage
stage(1). %we will always have a stage 1
reachableWithPreviousStageKeys(ID,S) :- levelStartRoom(ID), stage(S). %the first room is always reachable
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), not lock(ID1,ID2,_). %a room is reachable as long as there is no lock on the edge
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), lock(ID1,ID2,KN), keyCollected(KN,S-1). %or if we already have the key for the lock from a previous stage
keyCollected(KN,S) :- reachableWithPreviousStageKeys(ID,S), keyRoom(ID,KN). %If we reach a key we can use it next stage

numKeysCollected(N,S) :- N = #count{ KN : keyCollected(KN,S) } , stage(S). %count the number of keys collected

%finally we advance to the next stage if we don't have all the keys, and we have more keys then the previous stage 
numKeysCollected(0,0). %to simplfy checking the second critera let the nonexistent stage 0 have 0 keys collected
stage(S+1) :- stage(S), numKeysCollected(N1,S), numKeysCollected(N2,S-1), numKeys(TN), N1 != N2, N1 != TN, S <= TN.

allKeysCollected(0) :- numKeysCollected(N,S), numKeys(N). %if at any point we have collected the same number of keys as there exist keys we know are keys can be collected. (The 0 in the allKeysCollected is to prevent my parser from breaking on a niche case)

:- not allKeysCollected(0). %we must be able to collect all the keys

mustVisitXtoReachY(X,Y) :- keyRoom(X,KN), not reachableWithoutKey(Y,KN), room(Y,_,_,_). %for each key determine all the rooms we must visit the keyroom first to reach



%#show edgeNumber/1.
%#show numRooms/1.
%#show edge/2.
%#show room/1.
%#show levelStartRoom/1.
%#show finalRoom/1.
%#show reachableWithoutRooms/2.
%#show xBeforeY/2.

%#show threeCycle/1.

% #show finalRoom/1.
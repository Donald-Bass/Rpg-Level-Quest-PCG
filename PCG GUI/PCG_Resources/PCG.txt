%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

%Determine the number of rooms 
numRoomRange(minRooms .. maxRooms). %set a minimum and maximum number of rooms
1 { numRooms(X) : numRoomRange(X) } 1.

%Each room number corrosponds to a room
room(1 .. X) :- numRooms(X). 

0 { edge(X,Y) : room(Y), X != Y } 4 :- room(X).

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could violate the max number of edges out of a room
:- edge(X,Y), not edge(Y,X). 

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room
reachable(ID2) :- reachable(ID1), edge(ID1,ID2). %, finalRoom(IDF), ID1 != IDF.
:- room(ID), not reachable(ID).

%define number of connections
numConnections(ID,N) :- N = #count{ V : edge(ID,V) } , room(ID).
:- numberOfEdges(ID,C), numConnections(ID,N), C != N. %if a room has a set number of connections enforce that number

%define what it means for a room to come before
:- xBeforeY(X,Y), not reachableWithoutRooms(X,Y). %a room doesn't come before another one unless you can access the first without going through the second.

% % branches - %branch(W,X,Y,Z) a branch starting at w, where you can go through either X or Y to reach Z


%#show edgeNumber/1.
%#show numRooms/1.
%#show edge/2.
%#show room/1.
%#show levelStartRoom/1.
%#show finalRoom/1.
%#show reachableWithoutRooms/2.
%#show xBeforeY/2.

%#show threeCycle/1.

% #show finalRoom/1.

%Ok now to figure out multiple keys
%A locked door is passable if you can get to the key without passing through the door. 
%Problem A is having multiple doors. 
%Problem B is having a room you need to pass through to get the key count as coming before any room you need the key to reach
%Solution ? Reachable without key atom.
%. For problem A we have check. If key A is not reachable without key B, then key B must be reachable without Key A.
%	Question ? Does this work for any number of keys. No.
%   Need to do this check in multiple steps. Find all keys reachable without passing any locks. Then find any keys reachable by passing through those locks. Repeat until no more keys found or all keys reached.
%   Try to determine what keys every room needs to be reached as well.
%  Then for problem B we have a variant. If room X is not reachable without key Y, then room A comes before room X if room A needs to be passed through to get key Y.

%Key(ID,N) - Key N is in room ID
%Lock(X,Y,N) - the edge (X,Y) has a lock that requires Key N

%


% % Key code

% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1), not lockedDoorX(X1,Y1).
% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).

% % connectionNoKey(X2,Y2,X1,Y1) :- connectionNoKey(X1,Y1,X2,Y2).

% % connectedRoomsNoKey(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connectionNoKey(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


% % reachableNoKey(ID2) :- reachableNoKey(ID1), connectedRoomsNoKey(ID1,ID2).

% % 1 { lockedDoorX(X,Y) : doorX(X,Y) } 1.
% % 1 { keyRoom(ID) : roomID(_,_,ID) } 1.

% % :- keyRoom(ID1), levelStartRoom(ID2), ID1 == ID2. %make sure key isn't in the starting room.

% % :- keyRoom(ID), not reachableNoKey(ID).
% % :- 0 { roomID(_,_,ID) : not reachableNoKey(ID) } 1.

% % #show connectedRoomsNoKey/2.
% % #show reachable/1.
% % #show reachableNoKey/1.
% % #show lockedDoorX/2.
% % #show keyRoom/1.

% % Final framework details for flow

% % the start and end rooms must be unique
% :- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
% % :- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.

% roomType(empty).
% roomType(treasure).
% roomType(arena).

% 1 { typeOfRoom(ID,T) : roomType(T) } 1 :- rectangle(XUL,YUL,_,_,room), roomID(XUL,YUL,ID).

% :- typeOfRoom(ID,T1), typeOfRoom(ID,T2), T1 != T2.

% :- typeOfRoom(ID1,treasure), 3 {connectedRooms(ID1,ID2) }.
% :- levelStartRoom(ID), typeOfRoom(ID,treasure).
% :- finalRoom(ID), typeOfRoom(ID,treasure).
% % :- 0 { typeOfRoom(ID,treasure) : rectRange(ID) } 0. %try replacing this which a constraint that a room exists that is a treasure room (Also need constraint a room can't have two types)
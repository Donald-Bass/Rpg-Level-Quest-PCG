%counts syntax changed
%Changes. Hide doesn't work. Need to instead use show I believe
%Can't have multiple :'s inside {} replace all but the first with ,

%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------


areaSizeRange(minAreaSize..maxAreaSize). %range of possible area length/widths
wallSizeRange(0 .. maxAreaSize). %range of valid wall positions
floorSizeRange(0 .. (maxAreaSize - 1)). %range of valid floor positions
roomSizeRange(minLength .. maxLength).
%rectRange(0 .. maxRects).

%----------------------------------------------------------------------------
%Level Basics
%----------------------------------------------------------------------------

%determine the size of the area
1 { levelLengthX(X) : areaSizeRange(X) } 1. 
1 { levelLengthY(Y) : areaSizeRange(Y) } 1.

%determine valid tile numbers
lengthXDim(0..(X - 1)) :- levelLengthX(X).
lengthYDim(0..(Y - 1)) :- levelLengthY(Y).

%define tiles
%tile(X,Y) :- lengthXDim(X), lengthYDim(Y), level(L).

%---------------------------------------------------------------------------------
%Walls and other barricades
%---------------------------------------------------------------------------------

%walls have to be able to border entire area so valid dimensions range from 0 to X/Y 
wallXDim(0..X) :- levelLengthX(X). 
wallYDim(0..Y) :- levelLengthY(Y).

%wallX(X,Y) from X,Y to X+1,Y. The rightmost x is not a valid x for a wall on the x axis it can only be used for walls on the y Axis
{ wallX(X,Y) } :- wallXDim(X), wallYDim(Y).
{ doorX(X,Y) } :- wallXDim(X), wallYDim(Y).

%wallY(X,Y) from X,Y to X,Y+1. The bottommost y is not a valid y for a wall on the y axis it can only be used for walls on the x Axis
{ wallY(X,Y) } :- wallXDim(X), wallYDim(Y). 
{ doorY(X,Y) } :- wallXDim(X), wallYDim(Y). 

%There is no barricade that is freestanding
:- barricadeX(X,Y) , not barricadeX(X+1,Y), not barricadeX(X-1,Y), not barricadeY(X,Y), not barricadeY(X,Y-1).
:- barricadeY(X,Y) , not barricadeX(X,Y), not barricadeX(X-1,Y), not barricadeY(X,Y+1), not barricadeY(X,Y-1).

%Barricades are walls and anything else that occupies the same space (doors for example0
:- not wallX(X,Y), not doorX(X,Y), barricadeX(X,Y).
:- not wallY(X,Y), not doorY(X,Y), barricadeY(X,Y). 
:- wallX(X,Y), doorX(X,Y).
:- wallY(X,Y), doorY(X,Y).

%There should not be two doors side by side
:- doorX(X,Y), doorX((X-1),Y).
:- doorY(X,Y), doorY(X,(Y-1)).

barricadeX(X,Y) :- wallX(X,Y).
barricadeX(X,Y) :- doorX(X,Y).
barricadeY(X,Y) :- wallY(X,Y).
barricadeY(X,Y) :- doorY(X,Y).


%:- wallX(X,Y), not barricadeX(X,Y).
%:- wallY(X,Y), not barricadeY(X,Y). 

%----------------------------------------------------------------------------------------------------------------------------------------------
%Floors
%----------------------------------------------------------------------------------------------------------------------------------------------
%There must be a wall between any floor and non floor tile when the level is an interior
wallY(X,Y) :- floor(X,Y) , not floor((X - 1),Y).
wallY((X + 1),Y) :- floor(X,Y) , not floor((X + 1),Y).
wallX(X,Y) :- floor(X,Y) , not floor(X,(Y - 1)).
wallX(X,(Y+1)) :- floor(X,Y) , not floor(X,(Y + 1)).

%There must be a floor on at least one side of a wall
:- barricadeX(X,Y), not floor(X,Y), not floor(X,(Y-1)).
:- barricadeY(X,Y), not floor(X,Y), not floor((X-1),Y).

%Each level should have a starting tile along one of the edges
%1 { levelStart(X,Y) : floorSizeRange(X) , floorSizeRange(Y)} 1.

%:- levelStart(X,Y), not floor(X,Y). %the start must be on a floor

%The starting tile must be on one of the edges
%nonEdgeXDim(1..(X - 2)) :- levelLengthX(X). %Define non edge tiles
%nonEdgeYDim(1..(Y - 2)) :- levelLengthY(Y). %Define non edge tiles
%:- levelStart(X,Y), nonEdgeXDim(X), nonEdgeYDim(Y). %both dimensions of a level start can't be non edge dimensions


%------------------------------------------------------------------------------------------
%Reachable tiles
%------------------------------------------------------------------------------------------

step(0,-1 ;; 0,1 ;; 1,0 ;; -1,0). %Set up range of possible ways to move one tile over%

%The start of the level is automatically reachablea
%reachable(X,Y) :- levelStart(X,Y).

%A tile is reachable if it is one step from a reachable tile and connected to that tile
%reachable(NX,NY) :-
%  reachable(X,Y),
%  step(DX,DY),
% NX = X + DX,
%  NY = Y + DY,
% floor(NX,NY),
%  connection(NX,NY,X,Y).
  
%Every floor tile should be reachable (This is for the interior only right now because only the interior has a starting position, and there is nothing to block travel between tiles outdoor currently)
%:- floor(X,Y), not reachable(X,Y).

%-----------------------------------------------------------------------
% Indoor level Specific Elements
%------------------------------------------------------------------------

%A room (defined by the top left (XUL,YUL) and Bottom Right (XBR, YBR) corners
minRooms { room(XUL, YUL, LENGTH, HEIGHT) : floorSizeRange(XUL) , floorSizeRange(YUL) , roomSizeRange(LENGTH) , roomSizeRange(HEIGHT)} maxRooms.

corType(corX).
corType(corY).

minCor { corridor(X,Y,LENGTH, T) : floorSizeRange(X), roomSizeRange(LENGTH), floorSizeRange(Y), corType(T) } maxCor.

#show corridor/4.

corridorX(X, LENGTH, Y) :- corridor(X,Y,LENGTH,corX).

corridorY(Y, LENGTH, X) :- corridor(X,Y,LENGTH,corY).

%Rectangle covers shared rules for corriders and rooms
rectangle(XUL, YUL, (XUL + LENGTH - 1), (YUL + HEIGHT - 1), room) :- room(XUL, YUL, LENGTH, HEIGHT).
rectangle(XL, Y, (XL + LENGTH - 1), Y,corX)  :- corridorX(XL, LENGTH, Y).
rectangle(X, YU, X, (YU + LENGTH - 1),corY)  :- corridorY(YU, LENGTH, X).

:- rectangle(XUL, YUL, XBR, YBR,_), levelLengthX(X), XBR > X.
:- rectangle(XUL, YUL, XBR, YBR,_), levelLengthY(Y), YBR > Y.

floorType(X,Y,T) :- rectangle(XUL, YUL, XBR, YBR, T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor
floor(X,Y) :- floorType(X,Y,T). %seperate atom for when we need need a floor and the type of room it's from doesn't matter
corFloor(X,Y) :- floorType(X,Y,corX). %seperate atom for when we need a floor from a corridor
corFloor(X,Y) :- floorType(X,Y,corY). %seperate atom for when we need a floor from a corridor

%collision detection hack for each tile remember seperatly the 4 corners of the rectangle of the room it's from, if any tile has two of those registered there is a collision
floorXUL(X,Y,XUL,T) :- rectangle(XUL, YUL, XBR, YBR,T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor
floorYUL(X,Y,YUL,T) :- rectangle(XUL, YUL, XBR, YBR,T),  X >= XUL, X <= XBR, Y >= YUL, Y <= YBR, lengthXDim(X), lengthYDim(Y). %all tiles in the room must be floor

:- rectangle(XUL, YUL, XBR1, _,_), rectangle(XUL, YUL, XBR2, _,_), XBR1 != XBR2.
:- rectangle(XUL, YUL, _, YBR1,_), rectangle(XUL, YUL, _, YBR2, _), YBR1 != YBR2.
:- rectangle(XUL, YUL, _, _,T1), rectangle(XUL, YUL, _, _, T2), T1 != T2.

overLap(X,Y,T1,T2) :- floorXUL(X,Y,XUL1,T1), floorXUL(X,Y,XUL2,T2), XUL1 != XUL2.
overLap(X,Y,T1,T2) :- floorYUL(X,Y,YUL1,T1), floorYUL(X,Y,YUL2,T2), YUL1 != YUL2.

%What happens when rooms share the upper corner

%wallX(X,Y) from X,Y to X+1,Y. The rightmost x is not a valid x for a wall on the x axis it can only be used for walls on the y Axis

%there should be no overlap for rooms, and no overlap between two corridors along the same axis
:- overLap(X,Y,T1,T2), T1 = room. 
:- overLap(X,Y,T1,T2), T2 = room.
:- overLap(X,Y,T1,T2), T1 = T2.

:- overLap(X1,Y1,corX,corY), overLap(X2,Y2,corX,corY), X1 < X2, (X2 - X1) <= 2.
:- overLap(X1,Y1,corX,corY), overLap(X2,Y2,corX,corY), Y1 < Y2, (Y2 - Y1) <= 2.

roomBarricadeX(XW,YUL) :- rectangle(XUL, YUL, XBR, YBR,_), lengthXDim(XW), XW >= XUL, XW <= XBR. %add walls on top of the room
roomBarricadeX(XW,(YBR + 1)) :- rectangle(XUL, YUL, XBR, YBR,_), lengthXDim(XW), XW >= XUL, XW <= XBR. %add walls on bottom of the room
roomBarricadeY(XUL,YW) :- rectangle(XUL, YUL, XBR, YBR,_), lengthYDim(YW), YW >= YUL, YW <= YBR. %add walls on left of the room
roomBarricadeY((XBR + 1),YW) :- rectangle(XUL, YUL, XBR, YBR,_), lengthYDim(YW), YW >= YUL, YW <= YBR. %add walls on left of the room

%Add condition that neither side of the wall is an overlap
barricadeX(X,Y) :- roomBarricadeX(X,Y), not overLap(X,Y,corX,corY), not overLap(X,Y-1,corX,corY).
barricadeY(X,Y) :- roomBarricadeY(X,Y), not overLap(X,Y,corX,corY), not overLap(X-1,Y,corX,corY).

%wallX(X,Y) from X,Y to X+1,Y. The rightmost x is not a valid x for a wall on the x axis it can only be used for walls on the y Axis
%If there is an overlap and there is a room adjacent to the overlap the room should still have its wall

barricadeX(X,Y) :- roomBarricadeX(X,Y), overLap(X,Y,corX,corY), floorType(X,Y-1,room).   %Condition   R  (R = room, O = overlap)
																						               %           ---
																						               %            O
barricadeX(X,Y) :- roomBarricadeX(X,Y), overLap(X,Y-1,corX,corY), floorType(X,Y,room).   %Condition   O  (R = room, O = overlap)
																						               %           ---
																						               %            R
barricadeY(X,Y) :- roomBarricadeY(X,Y), overLap(X,Y,corX,corY), floorType(X-1,Y,room).   %Condition   R|O  (R = room, O = overlap)

barricadeY(X,Y) :- roomBarricadeY(X,Y), overLap(X-1,Y,corX,corY), floorType(X,Y,room).   %Condition   O|R  (R = room, O = overlap)					
					
:- barricadeX(X,Y), not roomBarricadeX(X,Y).
:- barricadeY(X,Y), not roomBarricadeY(X,Y).

%if there is an overlap between two corrdiors explictely prevent any barricades from blocking the junction between the associated corridor spaces
:- barricadeX(X,Y), overLap(X,Y-1,corX,corY), corFloor(X,Y), corFloor(X,Y-1). %this is probally a dupe of the second, same with the 3rd being a dupe of the 4th
:- barricadeX(X,Y), overLap(X,Y,corX,corY), corFloor(X,Y), corFloor(X,Y-1).
:- barricadeY(X,Y), overLap(X-1,Y,corX,corY), corFloor(X,Y), corFloor(X-1,Y).
:- barricadeY(X,Y), overLap(X,Y,corX,corY), corFloor(X,Y), corFloor(X-1,Y).

%TODO. Finish debugging

%TODO. add constraint, both ends of a corridor must be an overlap/have a door to a adjacent 

%define spaces that are the ends of cooridors
corEnd(XUL, YUL) :- rectangle(XUL, YUL, XBR, YBR, corX).
corEnd(XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, corX).
corEnd(XUL, YUL) :- rectangle(XUL, YUL, XBR, YBR, corY).
corEnd(XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, corY).

%check if there is a connection to a room in all 4 directions
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL-1,YUL), floorType(XUL-1,YUL,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL+1,YUL), floorType(XUL+1,YUL,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL,YUL-1), floorType(XUL,YUL-1,room).
corEndConnectedRoom(XUL,YUL) :- corEnd(XUL, YUL), connection(XUL,YUL,XUL,YUL+1), floorType(XUL,YUL+1,room).

%every end of a corridor must be connected to a room or overlapping another corridor
:- corEnd(XBR, YBR), not corEndConnectedRoom(XBR, YBR), not overLap(XBR, YBR,_,_).
%corridors shouldn't be parallel and adjacent. (Allow this though if the adjacent spaces are both edges of corridors, could create some intresting shapes)
:- floorType(X,Y,corX), floorType(X,Y-1,corX), not corEnd(X,Y).
:- floorType(X,Y,corY), floorType(X-1,Y,corY), not corEnd(X,Y).
:- floorType(X,Y,corX), floorType(X,Y-1,corX), not corEnd(X,Y-1).
:- floorType(X,Y,corY), floorType(X-1,Y,corY), not corEnd(X-1,Y).

%corridors should connect two or more rooms, or have 1 end be an overlap. To save memory only check connections at the ends. These is still moderatly memory intensive

%for each end of the corridor corridor, find all connected tiles that are in a room and store the upper left corner of that room (Since rooms can't overlap, that corner will be unique)
connectToRoomXUL(X,Y,XUL) :- corEnd(X,Y), connection(X,Y,X2,Y2), floorXUL(X2,Y2,XUL,room), step(DX,DY), X2 = X + DX, Y2 = Y + DY.
connectToRoomYUL(X,Y,YUL) :- connectToRoomXUL(X,Y,XUL), floorXUL(X,Y,XUL,room), floorYUL(X,Y,YUL,room).

%check both ends of corridor to see if room differs in x coordinate of upper left corner
connectsTwoRooms(XUL, YUL, XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, T), connectToRoomXUL(XUL, YUL, N1) , connectToRoomXUL(XBR, XBR, N2) , N1 != N2, T != room, N1 != XUL, N2 != XUL.

%check both ends of corridor to see if room differs in y coordinate of upper left corner
connectsTwoRooms(XUL, YUL, XBR, YBR) :- rectangle(XUL, YUL, XBR, YBR, T), connectToRoomYUL(XUL, YUL, N1) , connectToRoomYUL(XBR, XBR, N2) , N1 != N2, T != room, N1 != YUL, N2 != YUL.

%A corridor must bec connected to at least two rooms
:- rectangle(XUL, YUL, XBR, YBR, corX), not connectsTwoRooms(XUL, YUL, XBR, YBR), not overLap(XUL,YUL,corX,corY), not overLap(XBR,YBR,corX,corY).
:- rectangle(XUL, YUL, XBR, YBR, corY), not connectsTwoRooms(XUL, YUL, XBR, YBR), not overLap(XUL,YUL,corX,corY), not overLap(XBR,YBR,corX,corY).

%check if there are too many doors. From a door, go in each direction see if there are and perpendicular walls before another door is seen. (A perpendicular wall means the corridor/room on one side has ended
%Seems to be bugged

doorXOkay(X1,Y) :- doorX(X1,Y), doorX(X2,Y), wallY(X3,Y2), X1 < X2, X3 > X1, X3 < X2, Y2 <= Y, Y2 >= Y-1.
%:- doorX(X1,Y), doorX(X2,Y), X1 < X2, not doorXOkay(X1,Y).

doorYOkay(X,Y1) :- doorY(X,Y1), doorY(X,Y2), wallX(X2,Y3), Y1 < Y2, Y3 > Y1, Y3 < Y2, X2 <= X, X2 >= X-1.
%:- doorY(X,Y1), doorY(X,Y2), Y1 < Y2, not doorYOkay(X,Y1).

%a corridor must have at least one space that ia adjacent to 2 blocked tile
corridorXOkay(XUL,Y) :- rectangle(XUL,Y,XBR,Y,corX), floor(X,Y), X >= XUL, X <= XBR, not floor(X,Y - 1), not floor(X,Y + 1).
:- rectangle(XUL,Y,_,_,corX), not corridorXOkay(XUL,Y).

corridorYOkay(X,YUL) :- rectangle(X,YUL,X,YBR,corY), floor(X,Y), Y >= YUL, Y <= YBR, not floor(X - 1,Y), not floor(X + 1, Y).
:- rectangle(X,YUL,_,_,corY), not corridorYOkay(X,YUL).

%----------------------------------------------------------------------------------

edgeFloorType(X,Y,T) :- rectangle(X, YUL, _, YBR, T),  Y >= YUL, Y <= YBR, lengthYDim(Y). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(_, YUL, X , YBR, T),  Y >= YUL, Y <= YBR, lengthYDim(Y). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(XUL, Y, XBR, _ , T),  X >= XUL, X <= XBR, lengthXDim(X). %all tiles in the room must be floor
edgeFloorType(X,Y,T) :- rectangle(XUL, _, XBR, Y , T),  X >= XUL, X <= XBR, lengthXDim(X). %all tiles in the room must be floor

%2.0GB to add reachable constraints for 16x16. Better then I've gotten but not good enough
%Adding Key to 2.3 GB

rectRange(1..maxRects). %when this is changed to a constant need to change gui code

1 { roomID(XUL,YUL,I) : lengthXDim(XUL), lengthYDim(YUL), rectRange(I) } 1 :- rectangle(XUL,YUL,_,_,_).
:- roomID(XUL1,_,I), roomID(XUL2,_,I), XUL1 != XUL2.
:- roomID(_,YUL1,I), roomID(_,YUL2,I), YUL1 != YUL2.

edgeFloorID(XUL,YUL .. YBR,ID) :- rectangle(XUL, YUL, _, YBR, _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(X,YUL .. YBR,ID) :- rectangle(XUL, YUL, X , YBR, _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(XUL .. XBR,YUL,ID) :- rectangle(XUL, YUL, XBR, _ , _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor
edgeFloorID(XUL .. XBR,Y,ID) :- rectangle(XUL, YUL, XBR, Y , _),  roomID(XUL,YUL,ID). %all tiles in the room must be floor

edgeFloor(X,Y) :- edgeFloorID(X,Y,_).


connectedRooms(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connection(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


%connectedRooms(ID2,ID1) :- connectedRooms(ID1,ID2).

% %define what tiles are connected to what tiles
connection(X1,Y1,X2,Y2) :- floor(X1,Y1), floor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1).
% %connection(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 + 1) == Y2, not wallX(X2,Y2).
connection(X1,Y1,X2,Y2) :- floor(X1,Y1), floor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).
% %connection(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 + 1) == X2, not wallY(X2,Y2).



connection(X2,Y2,X1,Y1) :- connection(X1,Y1,X2,Y2).

%1 { levelStartRoom(ID) : roomID(_,_,ID) } 1.

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room

reachable(ID2) :- reachable(ID1), connectedRooms(ID1,ID2), finalRoom(IDF), ID1 != IDF.
:- roomID(_,_,ID), not reachable(ID).

%reachableWithoutX(START,X) :- levelStartRoom(START), roomID(_,_,X).
%reachableWithoutX(ID2,X) :- reachableWithoutX(ID1,X), connectedRooms(ID1,ID2), ID1 != X, finalRoom(IDF), ID1 != IDF.

%#show reachableWithoutX/2.

%Define a room as being  the end of the level
1 { finalRoom(ID) : roomID(_,_,ID) } 1.

#show finalRoom/1.

% Key code

% connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1), not lockedDoorX(X1,Y1).
% connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).

% connectionNoKey(X2,Y2,X1,Y1) :- connectionNoKey(X1,Y1,X2,Y2).

% connectedRoomsNoKey(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connectionNoKey(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


% reachableNoKey(ID2) :- reachableNoKey(ID1), connectedRoomsNoKey(ID1,ID2).

% 1 { lockedDoorX(X,Y) : doorX(X,Y) } 1.
% 1 { keyRoom(ID) : roomID(_,_,ID) } 1.

% :- keyRoom(ID1), levelStartRoom(ID2), ID1 == ID2. %make sure key isn't in the starting room.

% :- keyRoom(ID), not reachableNoKey(ID).
% :- 0 { roomID(_,_,ID) : not reachableNoKey(ID) } 1.

% #show connectedRoomsNoKey/2.
% #show reachable/1.
% #show reachableNoKey/1.
% #show lockedDoorX/2.
% #show keyRoom/1.

% Final framework details for flow

% the start and end rooms must be unique
:- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
%:- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.

roomIDExists(ID) :- roomID(_,_,ID). %a quick way to check if a certain ID number is used. Mainly this allows us to specify attributes of a room that needs to exist by an ID number and then have
									 % an integrity constraint using this atom that says a room with that ID must exist.

%NOTE. The one thing I did not have in previous tests was the 3 rooms you have to pass through to get to the end room. That apparently adds a lot of time									 
									
#show connection/4.
#show edgeFloor/2.
%#show levelStart/2. 
#show levelStartRoom/1.
#show edgeFloorID/3.
#show roomID/3.
#show connectedRooms/2.
#show reachable/1.
#show roomIDExists/1.


roomType(empty).
roomType(treasure).
roomType(arena).

1 { typeOfRoom(ID,T) : roomType(T) } 1 :- rectangle(XUL,YUL,_,_,room), roomID(XUL,YUL,ID).

:- typeOfRoom(ID,T1), typeOfRoom(ID,T2), T1 != T2.

:- typeOfRoom(ID1,treasure), 3 {connectedRooms(ID1,ID2) }.
:- levelStartRoom(ID), typeOfRoom(ID,treasure).
:- finalRoom(ID), typeOfRoom(ID,treasure).
%:- 0 { typeOfRoom(ID,treasure) : rectRange(ID) } 0. %try replacing this which a constraint that a room exists that is a treasure room (Also need constraint a room can't have two types)

%1 { chest(X,Y) : edgeFloorID(X,Y,ID) } 4 :- typeOfRoom(ID,treasure), rectangle(XUL,YUL,XBR,YBR,room), roomID(XUL,YUL,ID).

#show typeOfRoom/2.
%#show chest/2.


%Distance rules
roomCenter(ID,XC,YC) :- roomID(XUL,YUL,ID), rectangle(XUL,YUL,XBR,YBR,_), XC = (XUL + ((XBR - XUL) / 2)), YC = (YUL + ((YBR - YUL) / 2)).
%clingo 4 seems to have no absolute value so I need to improvise here
manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X1 - X2) + (Y1 - Y2), X1 >= X2, Y1 >= Y2.
manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X2 - X1) + (Y1 - Y2), X2 > X1, Y1 >= Y2.
manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X1 - X2) + (Y2 - Y1), X1 >= X2, Y2 > Y1.
manDist(ID1,ID2,DIST) :- findDist(ID1,ID2), roomCenter(ID1,X1,Y1), roomCenter(ID2,X2,Y2), DIST = (X2 - X1) + (Y2 - Y1), X2 > X1, Y2 > Y1.

%findDist(ID1,ID2) :- roomID(_,_,ID1), roomID(_,_,ID2), ID1 != ID2.

%link(ID2,ID1) :- link(ID1,ID2).

%TEST!
% findDist(ID1,ID2) :- noLink(ID1,ID2).
% noLink(1,3).
% noLink(2,4).

% :- noLink(ID1,ID2), manDist(ID1,ID2) < 6.

#show roomCenter/3.
#show manDist/3.

%-----------------------------------------
%Hidden elements
%------------------------------------
#show floor/2.
#show wallX/2.
#show wallY/2.
#show doorX/2.
#show doorY/2.
#show levelLengthX/1.
#show levelLengthY/1.
#show rectangle/5.
#show overLap/4.
#show roomBarricadeX/2.
#show roomBarricadeY/2.
#show barricadeX/2.
#show barricadeY/2.
#show room/4.
%#show connectsTwoRooms/5.
%#show corConnectsToRoomXUL/7.
%#show corConnectsToRoomYUL/7.
%#hide lengthXDim/2.
%#hide lengthYDim/2.
%#hide tile/3.
%#hide connectedUp/5.
%#hide connectedDown/5.
%#hide connectedRight/5.
%#hide connectedLeft/5.
%#hide connection/5.
%#hide wallSizeRange/1.
%#hide floorSizeRange/1.
%#hide wallXDim/2.
%#hide wallYDim/2.
%#hide barricadeX/3.
%#hide barricadeY/3.
%#hide nonEdgeXDim/2.
%#hide targetIndexRange/1.
%#hide nonEdgeXDim/2.
%#hide nonEdgeYDim/2.
%#hide npcNumRange/1.
%#hide questNumRange/1.
%#hide stageRange/1.
%#hide reachable/3.
%#hide levelNumRange/1.

%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

%Determine the number of rooms 
numRoomRange(minRooms .. maxRooms). %set a minimum and maximum number of rooms
1 { numRooms(X) : numRoomRange(X) } 1.

%Each room number corrosponds to a room
room(1 .. X) :- numRooms(X). 

0 { edge(X,Y) : room(Y), X != Y } 4 :- room(X).

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could violate the max number of edges out of a room
:- edge(X,Y), not edge(Y,X). 

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room
reachable(ID2) :- reachable(ID1), edge(ID1,ID2). %, finalRoom(IDF), ID1 != IDF.
:- room(ID), not reachable(ID).

%define number of connections
numConnections(ID,N) :- N = #count{ V : edge(ID,V) } , room(ID).
:- numberOfEdges(ID,C), numConnections(ID,N), C != N. %if a room has a set number of connections enforce that number

%define what it means for a room to come before
:- xBeforeY(X,Y), not reachableWithoutRooms(X,Y). %a room doesn't come before another one unless you can access the first without going through the second.

% % branches - %branch(W,X,Y,Z) a branch starting at w, where you can go through either X or Y to reach Z

%key code
numKeys(2). 
keyRange(1..X) :- numKeys(X).

% keyRoom(2,1).
% keyRoom(5,2).

% lock(1,3,1).
% lock(4,6,2).

1 { keyRoom(RN,KN) : room(RN) } 1 :- keyRange(KN). %the key KN is in room RN
1 { preLock(X,Y,KN) : edge(X,Y) } 1  :- keyRange(KN). %the lock KN opens is edge X,Y

%for some inexplicable reason using lock instead of preLock in the previous statement prevents the program from being satisifed.
lock(X,Y,KN) :- preLock(X,Y,KN).

lock(Y,X,KN) :- lock(X,Y,KN). %locks exist in both directions

%To simplify each room can only contain one key and each edge only 1 lock
:- keyRoom(RN,KN1), keyRoom(RN,KN2), KN1 != KN2.
:- lock(X,Y,KN1), lock(X,Y,KN2), KN1 != KN2.

%determine which rooms can be reached without each key
reachableWithoutKey(ID,KN) :- keyRange(KN), levelStartRoom(ID).
reachableWithoutKey(ID2,KN) :- reachableWithoutKey(ID1,KN), edge(ID1,ID2), not lock(ID1,ID2,KN).

:- keyRoom(RN,KN), not reachableWithoutKey(RN,KN). %a key cannot be stuck behind the lock it opens

roomsBlocked(KN) :- keyRange(KN), room(RN), not reachableWithoutKey(RN,KN). %check if any rooms are actually blocked off by the lock
:- keyRange(KN), not roomsBlocked(KN). %for now force each lock to actually lock something away.

%Ok now the trickest part. In a series of stages we need to make sure all the rooms can enventually be reached by collecting the keys in a proper order
%The first stage we have no keys collected and find all the keys we can collect without any keys. The second stage we find all the additional keys we can collect with those keys collected in the previous stage
stage(1). %we will always have a stage 1
reachableWithPreviousStageKeys(ID,S) :- levelStartRoom(ID), stage(S). %the first room is always reachable
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), not lock(ID1,ID2,_). %a room is reachable as long as there is no lock on the edge
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), lock(ID1,ID2,KN), keyCollected(KN,S-1). %or if we already have the key for the lock from a previous stage
keyCollected(KN,S) :- reachableWithPreviousStageKeys(ID,S), keyRoom(ID,KN). %If we reach a key we can use it next stage

numKeysCollected(N,S) :- N = #count{ KN : keyCollected(KN,S) } , stage(S). %count the number of keys collected

%finally we advance to the next stage if we don't have all the keys, and we have more keys then the previous stage 
numKeysCollected(0,0). %to simplfy checking the second critera let the nonexistent stage 0 have 0 keys collected
stage(S+1) :- stage(S), numKeysCollected(N1,S), numKeysCollected(N2,S-1), numKeys(TN), N1 != N2, N1 != TN, S <= TN.

allKeysCollected(0) :- numKeysCollected(N,S), numKeys(N). %if at any point we have collected the same number of keys as there exist keys we know are keys can be collected. (The 0 in the allKeysCollected is to prevent my parser from breaking on a niche case)

:- not allKeysCollected(0). %we must be able to collect all the keys

%#show edgeNumber/1.
%#show numRooms/1.
%#show edge/2.
%#show room/1.
%#show levelStartRoom/1.
%#show finalRoom/1.
%#show reachableWithoutRooms/2.
%#show xBeforeY/2.

%#show threeCycle/1.

% #show finalRoom/1.
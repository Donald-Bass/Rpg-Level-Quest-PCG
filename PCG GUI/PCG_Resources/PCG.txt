%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

%Determine the number of rooms 
numRoomRange(10 .. 10). %set a minimum and maximum number of rooms
1 { numRooms(X) : numRoomRange(X) } 1.

%Each room number corrosponds to a room
room(1 .. X) :- numRooms(X). 

1 { edge(X,Y) : room(Y), X != Y } 5 :- room(X).

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could violate the max number of edges out of a room
:- edge(X,Y), not edge(Y,X). 

%edgeNumber(N) :- N = #count{ X,Y : edge(X,Y) }.

%in a planar graph e < 3v-6 (also remember edgeNumber is 2e)
%:- edgeNumber(E), numRooms(V), (E / 2) >= ((3 * V) - 6).

%if there isn't a 3 cycle then e < 2v-4
%threeCycle(1) :- room(A), room(B), room(C), edge(A,B), edge(B,C), edge(C,A).
%:- not threeCycle(1), edgeNumber(E), numRooms(V), (E / 2) >= ((2 * V) - 4).

%1 { levelStartRoom(ID) : room(ID) } 1.
levelStartRoom(1).

reachable(ID) :- levelStartRoom(ID). %The start has to be on the edge of the level so it has to been on the edge of a room
reachable(ID2) :- reachable(ID1), edge(ID1,ID2). %, finalRoom(IDF), ID1 != IDF.
:- room(ID), not reachable(ID).

%reachableWithoutXY(START,X,Y) :- levelStartRoom(START), room(X), room(Y).
%reachableWithoutXY(ID2,X,Y) :- reachableWithoutXY(ID1,X,Y), edge(ID1,ID2), ID1 != X, ID1 != Y, finalRoom(IDF), ID1 != IDF.

% % Define a room as being  the end of the level
%1 { finalRoom(ID) : room(ID) } 1.
finalRoom(5).

% the start and end rooms must be unique
:- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
:- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.
:- finalRoom(ID), levelStartRoom(ID).


%Defining ordering of rooms 
reachableWithoutX(START,X) :- levelStartRoom(START), room(X).
reachableWithoutX(ID2,X) :- reachableWithoutX(ID1,X), edge(ID1,ID2), ID1 != X. % finalRoom(IDF), ID1 != IDF.  Final room is not useful for now

:- reachableWithoutX(Y,X), xBeforeY(X,Y).
xBeforeY(1,2).


%branches - %branch(W,X,Y,Z) a branch starting at w, where you can go through either X or Y to reach Z

 %since the split is at W W has to be before everything
xBeforeY(W,X) :- branch(W,X,Y,Z).
xBeforeY(W,Y) :- branch(W,X,Y,Z).
xBeforeY(W,Z) :- branch(W,X,Y,Z).

%you should be able to go to either branch without going through the other
:- branch(W,X,Y,Z), not reachableWithoutX(Y,X). 
:- branch(W,X,Y,Z), not reachableWithoutX(X,Y).

%the end should be reachable without going down A specific branch
:- branch(W,X,Y,Z), not reachableWithoutX(Z,X). 
:- branch(W,X,Y,Z), not reachableWithoutX(Z,Y).


%find what is reachable without going down either branch
reachableWithout(ID2,X,Y) :- reachableWithout(ID1,X,Y), edge(ID1,ID2), ID1 != X, ID1 != Y. % finalRoom(IDF), ID1 != IDF.  Final room is not useful for now
reachableWithout(START,X,Y) :- branch(W,X,Y,Z), levelStartRoom(START).

:- branch(W,X,Y,Z), reachableWithout(Z,X,Y).

branch(2,3,4,5).

%world def
xBeforeY(5,6).
branch(6,7,8,9).
xBeforeY(9,10).

%#show edgeNumber/1.
#show numRooms/1.
#show edge/2.
#show room/1.
#show levelStartRoom/1.
#show finalRoom/1.
#show reachableWithoutX/2.
#show xBeforeY/2.

%#show threeCycle/1.

% #show finalRoom/1.


% % Key code

% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1), not lockedDoorX(X1,Y1).
% % connectionNoKey(X1,Y1,X2,Y2) :- edgeFloor(X1,Y1), edgeFloor(X2,Y2), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1).

% % connectionNoKey(X2,Y2,X1,Y1) :- connectionNoKey(X1,Y1,X2,Y2).

% % connectedRoomsNoKey(ID1,ID2) :- edgeFloorID(X1,Y1,ID1), edgeFloorID(X2,Y2,ID2),  connectionNoKey(X1,Y1,X2,Y2), step(DX,DY), X2 = X1 + DX, Y2 = Y1 + DY.


% % reachableNoKey(ID2) :- reachableNoKey(ID1), connectedRoomsNoKey(ID1,ID2).

% % 1 { lockedDoorX(X,Y) : doorX(X,Y) } 1.
% % 1 { keyRoom(ID) : roomID(_,_,ID) } 1.

% % :- keyRoom(ID1), levelStartRoom(ID2), ID1 == ID2. %make sure key isn't in the starting room.

% % :- keyRoom(ID), not reachableNoKey(ID).
% % :- 0 { roomID(_,_,ID) : not reachableNoKey(ID) } 1.

% % #show connectedRoomsNoKey/2.
% % #show reachable/1.
% % #show reachableNoKey/1.
% % #show lockedDoorX/2.
% % #show keyRoom/1.

% % Final framework details for flow

% % the start and end rooms must be unique
% :- finalRoom(ID1), finalRoom(ID2), ID1 != ID2.
% % :- levelStartRoom(ID1), levelStartRoom(ID2), ID1 != ID2.

% roomType(empty).
% roomType(treasure).
% roomType(arena).

% 1 { typeOfRoom(ID,T) : roomType(T) } 1 :- rectangle(XUL,YUL,_,_,room), roomID(XUL,YUL,ID).

% :- typeOfRoom(ID,T1), typeOfRoom(ID,T2), T1 != T2.

% :- typeOfRoom(ID1,treasure), 3 {connectedRooms(ID1,ID2) }.
% :- levelStartRoom(ID), typeOfRoom(ID,treasure).
% :- finalRoom(ID), typeOfRoom(ID,treasure).
% % :- 0 { typeOfRoom(ID,treasure) : rectRange(ID) } 0. %try replacing this which a constraint that a room exists that is a treasure room (Also need constraint a room can't have two types)
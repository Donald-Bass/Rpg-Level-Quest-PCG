%----------------------------------------------------------------------------
%Framework for the pcg. Contains general rules for creating any level. Note that a number of comments will refer to the WorldDef file. This is generated by the UI and contains all the rules for creating a specific level, inst
%----------------------------------------------------------------------------

%Dimensions of the grid to lay out rooms on. If you change these ranges you need to update the values in the LevelBuilder class as well.
xRange(0..9).
yRange(0..9).

%Determine the number of rooms 
numRoomRange(minRooms .. maxRooms). %Set a range of allowable values for the number of rooms in the level (minRooms and maxRooms are from the WorldDef file)
1 { numRooms(X) : numRoomRange(X) } 1. %choose a specific number within the minimum and maximum to be the number of rooms

roomRange(1 .. X) :- numRooms(X). %Find the range of room numbers corrosponding to the number of rooms

%Each room number corrosponds to a room, which has coordinates and a type
1 { room(N,X,Y,T) : xRange(X), yRange(Y) } 1 :- roomRange(N), typeOfRoom(N,T). %N is the room number, X and Y are the coordinates, T is the type of room (typeOfRoom is set in the WorldDef File)

:- room(N1,X,Y,_), room(N2,X,Y,_), N1 != N2. %two different rooms cannot share the same set of coordinates

%for the sake of testing at the moment no two rooms may be adjacent
%:- room(N1,X1,Y,_), room(N2,X2,Y,_), N1 != N2, X2 - 1 = X1.
%:- room(N1,X,Y1,_), room(N2,X,Y2,_), N1 != N2, Y2 - 1 = Y1.

1 { basicEdge(U,V) : room(V,_,_,_), U != V } 4 :- room(U,_,_,_). %Each room can have 1 to 4 edges leading from it to other rooms X and Y here are the numbers of the two rooms the edge connects
																	 %The minimum of 1 edge is to ensure the room is connected to the rest of the graph. The max of 4 is due to keep laying the rooms out simple, since to keep things 
																	 %simple each room is allowed to have only 1 corridor going in each cardinal direction

%all edges must be two ways. This is an intergrity constraint and not an implication, as just making each edge two ways could result in a room with more edges connecting it to other rooms then allowed
:- basicEdge(U,V), not basicEdge(V,U). 

%Check if the edges chosen result in a connected graph where all rooms can be reached
reachable(ID) :- levelStartRoom(ID). %The start of the level is by definition reachable
reachable(ID2) :- reachable(ID1), basicEdge(ID1,ID2). %a room is reachable if there is an edge between it and an already reachable room
:- room(ID,_,_,_), not reachable(ID). %forbid all rooms from not being reachable

%Determine how many edges each room has connected to it
numConnections(ID,N) :- N = #count{ V : basicEdge(ID,V) } , room(ID,_,_,_). %count each edge once that has the room as it's first endpoint (Since each edge is two way (X,Y), and (Y,X) both exist this gives the right count

%define The concept of a room coming before another room There are two versions we care about
%xBeforeY that says you have to visit room x before you can visit room Y. 
%xOptionalBeforeY says you it is possible to visit x without visiting y, but you don't have to visit x to visit y

%Determine what rooms can be reached without passing through specific rooms
%reachableWithoutRooms(ID1,ID2) means the room ID1 can be reached without passing through the room ID2. This is set up so that reachableWithoutRooms(ID1,ID1) will pretty much always be true, as it blocks paths that leave the room ID2, not that enter this
%Doing it in this fashion helps with some edge cases
reachableWithoutRooms(START,FB1) :- levelStartRoom(START), room(FB1,_,_,_). %The start room can be reached without passing through a specific room no matter what that room is
reachableWithoutRooms(ID2,FB1) :- reachableWithoutRooms(ID1,FB1), basicEdge(ID1,ID2), ID1 != FB1. %otherwise a room can be reached without going through another room, if there is a room the first is adjacent to that can be reached without going through said room

mustVisitXtoReachY(X,Y) :- room(X,_,_,_), room(Y,_,_,_), not reachableWithoutRooms(Y,X). %Now we reverse the results to find which rooms can't be reached without passing through particular rooms which is the form we actually need
																							  %mustVisitXtoReachY(X,Y) means that the only paths to room Y from the starting room require you to pass through room X.

																						 
mustVisitXtoReachY(X,Z)	:-	mustVisitXtoReachY(X,Y), mustVisitXtoReachY(Y,Z). %this property is transative. If you must visit room X to visit Y and Y to visit Z logically you must visit X to reach Z. This rule may seem pointless now
																				%but it is required to make the key code work
						
:- xBeforeY(X,Y), not mustVisitXtoReachY(X,Y). %a room doesn't come before another one unless you can't access the second without going through the first.

%Make sure the layout of the rooms works
%You'll see a lot of U < V constraints here. This is to simplfy things. Each basicEdge is present in two forms (U,V) and (V,U). We really don't want to duplicate work and have to worry about dealing with both copies so by checking for U < V  we ensure only 
%one of the two copies is used. (And we don't need to worry about the case U == V. That was disallowed in the rule that creates the basicEdge atoms

%Check what direction each edge goes in
horEdge(U,V) :- basicEdge(U,V), U < V, room(U, X1, Y,_), room(V, X2, Y,_).  %a edge is horiziontal if it connects two rooms with the same Y coordinate but different X's
vertEdge(U,V) :- basicEdge(U,V), U < V, room(U, X, Y1,_), room(V, X, Y2,_). %a edge is vertical if it connects two rooms with the same X coordinate but different Y's

:- basicEdge(U,V), U < V, not horEdge(U,V), not vertEdge(U,V). %Only allow edges that are vertical or horizontal to simplfy things

%Check to make sure the distances between rooms isn't too far. (A really long corridor isn't great gameplay)
%Despite there being only two cases horizontal and vertical we need four rules since we don't know whether U is on the left/top or the right/bottom of the edge, so we need to check which is true
%Remember 0,0 is the top left corner of the grid
:- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X1 < X2, D = X2 - X1, D > 4.  %If U is on the left
:- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X2 < X1, D = X1 - X2, D > 4.  %If U is on the right
:- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y1 < Y2, D = Y2 - Y1, D > 4. %If U is at the top
:- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y2 < Y1, D = Y1 - Y2, D > 4. %If U is at the bottom

%Mark each tile covered by the edge as occupied. We have 4 rules for the same resion as previously stated
%Occupied(X,Y,U,V) means the coordinates X,Y are occupied by the edge U,V
occupied(X3,Y,U,V) :- horEdge(U,V), room(U,X1,Y,_), room(V,X2,Y,_), X1 < X2, xRange(X3), X3 > X1, X3 < X2.
occupied(X3,Y,U,V) :- horEdge(U,V), room(U,X2,Y,_), room(V,X1,Y,_), X1 < X2, xRange(X3), X3 > X1, X3 < X2.
occupied(X,Y3,U,V) :- vertEdge(U,V), room(U,X,Y1,_), room(V,X,Y2,_), Y1 < Y2, yRange(Y3), Y3 > Y1, Y3 < Y2.
occupied(X,Y3,U,V) :- vertEdge(U,V), room(U,X,Y2,_), room(V,X,Y1,_), Y1 < Y2, yRange(Y3), Y3 > Y1, Y3 < Y2.

:- occupied(X,Y,_,_), room(_,X,Y,_). %Forbid any rooms from being at a coordinate occupied by an edge
%A coordinate cannot be occupied by two different edges (we can check that by seeing if either room number differs between two occupied atoms at the same coordinate)
%Remember there is an U < V check earlier which ensures that there aren't two versions of the same edge with different orders of room numbers
:- occupied(X,Y,U1,_), occupied(X,Y,U2,_), U1 != U2. 
:- occupied(X,Y,_,V1), occupied(X,Y,_,V2), V1 != V2.

%This is probally uneccessary. The idea was to create an edge atom to represent the final edge that has been verified to be correct, but there isn't anything this does the basicEdge Atom can't. The only reason I don't remove this is a number of parts
%of my code reference edge instead of basicEdge due to me not realizing this immediatly
edge(U,V) :- horEdge(U,V).
edge(U,V) :- vertEdge(U,V).
edge(V,U) :- edge(U,V).

%Code for placing keys and locked doors

%Define the minimum and maximum number of keys in a level. This should probally be moved to the worldDef file at some point
#const minKeys = 1. 
#const maxKeys = 3.
possibleNumKeysRange(minKeys .. maxKeys). %determine the range of possible numbers of keys

1 {numKeys(N) : possibleNumKeysRange(N) } 1. %determine the number of keys in the level within the accepted ranged of numbers 
keyRange(1..X) :- numKeys(X). %Determine the actual range of key numbers

%Place the keys in rooms, and locks in edges
1 { keyRoom(RN,KN) : room(RN,_,_,_) } 1 :- keyRange(KN). %the key KN is in room RN
1 { preLock(X,Y,KN) : basicEdge(X,Y) } 1  :- keyRange(KN). %the lock KN opens is edge X,Y

%for some inexplicable reason using lock instead of preLock in the previous statement prevents the program from being satisifed but I can convert the preLock to a lock here just fine
lock(X,Y,KN) :- preLock(X,Y,KN).

lock(Y,X,KN) :- lock(X,Y,KN). %locks exist in both directions

%Perform some sanity checks to prevent keys from being placed in rooms that make them trivial to the flow of the level
:- keyRoom(RN,KN), lock(RN,RN2,KN). %A key should not be in the same room the locked corridor connects with
:- keyRoom(RN,KN), lock(RN2,_,KN), not reachableWithoutRooms(RN2, RN). %There is no point in having a key in a room if the only way to reach one of the rooms around the lock is through the key room in the first place

%To simplify each room can only contain one key and each edge only 1 lock
:- keyRoom(RN,KN1), keyRoom(RN,KN2), KN1 != KN2. 
:- lock(X,Y,KN1), lock(X,Y,KN2), KN1 != KN2.

%determine which rooms can be reached without each key
reachableWithoutKey(ID,KN) :- keyRange(KN), levelStartRoom(ID). %For every key the start of the level can be reached without the key
reachableWithoutKey(ID2,KN) :- reachableWithoutKey(ID1,KN), basicEdge(ID1,ID2), not lock(ID1,ID2,KN). %a room can be reached without a key if there is an edge leading between that room and another room that can already be reached without the key
																										 %and that edge is not locked requiring that specific key

:- keyRoom(RN,KN), not reachableWithoutKey(RN,KN). %forbid a key from being stuck behind a lock that requires said key to open

roomsBlocked(KN) :- keyRange(KN), room(RN,_,_,_), not reachableWithoutKey(RN,KN). %check for each key that at least one room can only be reached through a lock requiring said key
:- keyRange(KN), not roomsBlocked(KN). %for now force each lock to actually block off access to at least one room.

%Ok now the trickest part. We need to check that every room is reachable ultimately through some possible order of collecting keys. To do so we are going to work in stages. The first
%stage starts with no keys having been collected and checking what rooms are reachable with no keys.
%Then for each subsequent stage  we will collect all keys that are in reachable rooms and find all the new reachable rooms
%we will repeat this up to TN times where (TN is the number of keys), until we either can collect all the keys (so every room is reachable) or we had a stage where we did not collect any new keys, (so no new rooms are reachable and we are basically at a dead end)

stage(1). %we will always have a stage 1
reachableWithPreviousStageKeys(ID,S) :- levelStartRoom(ID), stage(S). %the first room is always reachable
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), not lock(ID1,ID2,_). %a room is reachable as long as there is no lock on the edge
reachableWithPreviousStageKeys(ID2,S) :- reachableWithPreviousStageKeys(ID1,S), edge(ID1,ID2), lock(ID1,ID2,KN), keyCollected(KN,S-1). %or if we already have the key for the lock from a previous stage
keyCollected(KN,S) :- reachableWithPreviousStageKeys(ID,S), keyRoom(ID,KN). %If we can reach a key we can use it next stage

numKeysCollected(N,S) :- N = #count{ KN : keyCollected(KN,S) } , stage(S). %count the number of keys collected

%finally we advance to the next stage if we don't have all the keys, and we have more keys then the previous stage 
numKeysCollected(0,0). %to simplfy checking the second critera let the nonexistent stage 0 have 0 keys collected
stage(S+1) :- stage(S), numKeysCollected(N1,S), numKeysCollected(N2,S-1), numKeys(TN), N1 != N2, N1 != TN, S <= TN. %go to the next stage, if we have no collected all the keys but have collected more keys then the previous stage
																													    %(Technically we are just checking if we have not collected the same number of keys as the previous stage, but there is no way to collect less
																														%So the check is equivilent to checking if we've collected more)
																														%Also the S <= TN clause is necessary for Clingo to process this correctly. Our rules for when to advance to the next stage automatically 
																														%limit the number of stages possible due to their being finite keys and having to collect at least one key each stage to keep going. 
																														%Clingo isn't smart enough to know this though, so without the S <= TN it will keep grounding endlessly, trying to prepare for a potentially
																														%Infinite number of stages. Obviously this means Clingo never finishes

allKeysCollected(0) :- numKeysCollected(N,S), numKeys(N). %if at any point we have collected the same number of keys as there exist keys we know are keys can be collected. (The 0 in the allKeysCollected is to prevent my parser from breaking on a 
														   %niche case where it doesn't handle empty atoms well in some circumstances)

:- not allKeysCollected(0). %we must be able to collect all the keys

mustVisitXtoReachY(X,Y) :- keyRoom(X,KN), not reachableWithoutKey(Y,KN), room(Y,_,_,_). %for each key determine all the rooms we must visit the keyroom first to reach

%Create some additional atoms to make parsing the output easier
uniqueEdge(U,V) :- edge(U,V), U < V, not lock(U,V,_). %Create a version of the edge atom such that each edge only appears a single time (instead of having both the nomral (v,u) and (u,v) forms). Also don't include edges that have locked doors
														 %as this makes some parts of  parsing easier
														 
uniqueLock(U,V,KN) :- lock(U,V,KN), U < V. %and create a similar atom for locks
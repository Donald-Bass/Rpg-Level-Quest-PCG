%----------------------------------------------------------------------------
%Framework
%----------------------------------------------------------------------------

#const maxAreaSize=32.  %32. %maximum length of a side in number of tiles in an area 
#const minAreaSize=2. %minimum length of a side in number of tiles in an area
#const numLevels=2.
#const maxNumberOfNpcs=100. %maximum number of npcs that can be generated
#const maxNumberOfItems=100. %maximum number of itesm that can be generated
#const maxTargetIndex=100. %should be set to the larger of the two above values
#const maxQuestStages=100. %maximum number of quest stages that can be generated
#const numQuests=1.

areaSizeRange(minAreaSize..maxAreaSize). %range of possible area length/widths
wallSizeRange(0 .. maxAreaSize). %range of valid wall positions
floorSizeRange(0 .. (maxAreaSize - 1)). %range of valid floor positions
#hide areaSizeRange/1. %do not print range

%----------------------------------------------------------------------------
%Level Basics
%----------------------------------------------------------------------------

level(indoor_dungeon).
interior(indoor_dungeon).
level(outdoors).
exterior(outdoors).

%A level must be either outside or inside, but not both
:- level(x), not interior(x), not exterior(x). 
:- level(x), interior(x), exterior(x). 

%determine the size of the area
{ levelLengthX(X,L) : areaSizeRange(X) :level(L) }. 
{ levelLengthY(Y,L) : areaSizeRange(Y) :level(L) }. 

%A level cannot have two different lengths
:- levelLengthX(X1,L), levelLengthX(X2,L), X1 != X2.
:- levelLengthY(Y1,L), levelLengthY(Y2,L), Y1 != Y2.

%determine valid tile numbers
lengthXDim(0..(X - 1), L) :- levelLengthX(X, L).
lengthYDim(0..(Y - 1), L) :- levelLengthY(Y, L).
#hide lengthXDim/2.
#hide lengthYDim/2.

%define tiles
tile(X,Y,L) :- lengthXDim(X,L), lengthYDim(Y,L), level(L).

%#hide tile/3.

%define walls

%walls have to be able to border entire area so valid dimensions range from 0 to X/Y 
wallXDim(0..X , L) :- levelLengthX(X, L). 
wallYDim(0..Y , L) :- levelLengthY(Y, L).

%wallX(X,Y,L) from X,Y to X+1,Y. The rightmost x is not a valid x for a wall on the x axis it can only be used for walls on the y Axis
{ wallX(X,Y,L) : wallSizeRange(X) : wallSizeRange(Y) : level(L) }. 
:- wallX(X,Y,L) , not wallXDim(X,L). %all walls must have a valid x
:- wallX(X,Y,L), levelLengthX(X,L). %check that wall does not start at rightmost x
:- wallX(X,Y,L), not wallYDim(Y,L). %all walls must have a valid y 
:- wallX(X,Y,L), not interior(L). %only interiors have walls


%wallY(X,Y,L) from X,Y to X,Y+1. The bottommost y is not a valid y for a wall on the y axis it can only be used for walls on the x Axis
{ wallY(X,Y,L) : wallSizeRange(X) : wallSizeRange(Y) : level(L) }. 
:- wallY(X,Y,L) , not wallXDim(X,L). %all walls must have a valid x
:- wallY(X,Y,L), levelLengthY(Y,L). %check that wall does not start on bottommost y
:- wallY(X,Y,L), not wallYDim(Y,L).  %all walls must have a valid y
:- wallY(X,Y,L), not interior(L). %only interiors have walls

%Barricades are walls and anything else that occupies the same space (doors for example0
barricadeX(X,Y,L) :- wallX(X,Y,L).
barricadeY(X,Y,L) :- wallY(X,Y,L).

%There is no barricade that is freestanding
:- barricadeX(X,Y,L) , not barricadeX(X+1,Y,L), not barricadeX(X-1,Y,L), not barricadeY(X,Y,L), not barricadeY(X,Y-1,L).
:- barricadeY(X,Y,L) , not barricadeX(X,Y,L), not barricadeX(X-1,Y,L), not barricadeY(X,Y+1,L), not barricadeY(X,Y-1,L).

%define floors
16 { floor(X,Y,L) : floorSizeRange(X) : floorSizeRange(Y) : level(L) } :- level(L).

%15 { floor(X,Y,indoor_dungeon) : floorSizeRange(X) : floorSizeRange(Y) : level(indoor_dungeon) } :- level(indoor_dungeon).

:- floor(X,Y,L) , not tile(X,Y,L). %all floors must be on valid tiles
:- tile(X,Y,L), not floor(X,Y,L), exterior(L). %all tiles must be floors outdoors

%There must be a wall between any floor and non floor tile when the level is an interior
:- floor(X,Y,L) , not floor((X - 1),Y,L), not wallY(X,Y,L), interior(L).
:- floor(X,Y,L) , not floor((X + 1),Y,L), not wallY((X + 1),Y,L), interior(L).
:- floor(X,Y,L) , not floor(X,(Y - 1),L), not wallX(X,Y,L), interior(L).
:- floor(X,Y,L) , not floor(X,(Y + 1),L), not wallX(X,(Y+1),L), interior(L).

%There must be a floor on at least one side of a wall
:- wallX(X,Y,L), not floor(X,Y,L), not floor(X,(Y-1),L).
:- wallY(X,Y,L), not floor(X,Y,L), not floor((X-1),Y,L).

%Each level should have a starting tile along one of the edges
1 { levelStart(X,Y,L) : floorSizeRange(X) : floorSizeRange(Y) : level(L) } 1. 

:- levelStart(X,Y,L), not floor(X,Y,L). %the start must be on a floor
:- levelStart(X,Y,L), exterior(L). %only interiors have a starting point for now

%The starting tile must be on one of the edges
nonEdgeXDim(1..(X - 2), L) :- levelLengthX(X, L). %Define non edge tiles
nonEdgeYDim(1..(Y - 2), L) :- levelLengthY(Y, L). %Define non edge tiles
:- levelStart(X,Y,L), nonEdgeXDim(X,L), nonEdgeYDim(Y,L). 

%define what tiles are connected to what tiles
{ connection(X1,Y1,X2,Y2, L) : floorSizeRange(X1) : floorSizeRange(Y1) : floorSizeRange(X2) : floorSizeRange(Y2) : level(L) }. 

connectedUp(X1,Y1,X2,Y2,L) :- floor(X1,Y1,L), floor(X2,Y2,L), X1 == X2, (Y1 - 1) == Y2, not wallX(X1,Y1,L).
connectedDown(X1,Y1,X2,Y2,L) :- floor(X1,Y1,L), floor(X2,Y2,L), X1 == X2, (Y1 + 1) == Y2, not wallX(X2,Y2,L).
connectedLeft(X1,Y1,X2,Y2,L) :- floor(X1,Y1,L), floor(X2,Y2,L), Y1 == Y2, (X1 - 1) == X2, not wallY(X1,Y1,L).
connectedRight(X1,Y1,X2,Y2,L) :- floor(X1,Y1,L), floor(X2,Y2,L), Y1 == Y2, (X1 + 1) == X2, not wallY(X2,Y2,L).

%two connected tiles cannot be connected in none of the 4 directions(aka two connected tiles must be connected in one of the four directions)
:- connection(X1,Y1,X2,Y2,L), not connectedUp(X1,Y1,X2,Y2,L), not connectedDown(X1,Y1,X2,Y2,L), not connectedLeft(X1,Y1,X2,Y2,L), not connectedRight(X1,Y1,X2,Y2,L).

%------------------------------------------------------------------------------------------
%Define what tiles are reachable
%------------------------------------------------------------------------------------------

step(0,-1 ;; 0,1 ;; 1,0 ;; -1,0). %Set up range of possible ways to move one tile over

%The start of the level is automatically reachable
reachable(X,Y,L) :- levelStart(X,Y,L).

reachable(NX,NY,L) :-
  reachable(X,Y,L),
  step(DX,DY),
  NX = X + DX,
  NY = Y + DY,
  floor(NX,NY,L),
  connection(NX,NY,X,Y,L).
  
%Every floor tile should be reachable
:- floor(X,Y,L), not reachable(X,Y,L), interior(L).

%-----------------------------------------------------------------------
% Indoor level Specific Elements
%------------------------------------------------------------------------

%------------------------------------------------------------------------
%Outdoor level specific elements
%------------------------------------------------------------------------

10 { tree(X,Y,L) : floorSizeRange(X) : floorSizeRange(Y) : level(L) } 50.
:-  tree(X,Y,L), not tile(X,Y,L). %trees must be on valid tiles
:-  tree(X,Y,L), not exterior(L). %trees must be outside

%-----------------------------------------------
%Planning With help from Answer set programming and plan generation
%http://www.sciencedirect.com/science/article/pii/S0004370202001868
%-----------------------------------------------

%NPC
npcNumRange(1..maxNumberOfNpcs). %each npc will be identified with a number (they will be given names during the conversion to an actual module
{ npc(NPCN) : npcNumRange(NPCN) }. %each npc has an identifying number

{ friendly(NPCN): npcNumRange(NPCN)}. %states that npc N is friendly
{ hostile(NPCN): npcNumRange(NPCN)}. %states that npc N is hostile
%npc location

:- friendly(NPCN) , not npc(NPCN). 
:- hostile(NPCN) , not npc(NPCN).
:- npc(NPCN), not friendly(NPCN), not hostile(NPCN). %all npcs are either friendly or hostile
:- npc(NPCN), friendly(NPCN), hostile(NPCN). %no npc is both friendly and hostile

1 { npcLocation(NPCN,X,Y,L) : npcNumRange(NPCN) : floorSizeRange(X) : floorSizeRange(Y) : level(L) } 1 :- npc(NPCN).%for every npc there is one location they are located
:- npcLocation(NPCN,X,Y,L), not floor(X,Y,L). %NPCS must be located on floor tiles

questNumRange(1..numQuests). %each quest will be each npc will be identified with a number (they will be given names during the conversion to an actual module)
numQuests { quest(QN) : questNumRange(QN) } numQuests. %each npc has an identifying number

numQuests { questGiver(QN, NPCN) : questNumRange(QN) : npcNumRange(NPCN)} numQuests. %each quest has an npc that gives the quest
:- questGiver(QN, NPCN), not quest(QN).
:- questGiver(QN, NPCN), not npc(NPCN).
:- questGiver(QN, NPCN), hostile(NPCN). %the quest giver cannot be hostile 
:- questGiver(QN, NPCN1), questGiver(QN, NPCN2), NPCN1 != NPCN2. %the quest giver cannot be hostile 

typeOfObjective(kill).
%typeOfObjective(fetch).

1 { questObjectiveType(QN, OBJTYPE) : questNumRange(QN) : typeOfObjective(OBJTYPE) } 1 :- quest(QN).
%:- questObjectiveType(QN, OBJTYPE1), questObjectiveType(QN, OBJTYPE2), OBJTYPE1 != OBJTYPE2.

targetIndexRange(1..maxTargetIndex). %range of possible indexs for the quest target
1 { questTarget(QN, T) : questNumRange(QN) : targetIndexRange(T) }  1 :- quest(QN). %the target of a quest (a npc/item to fetch/kill)
:- questTarget(QN1, T), questTarget(QN2, T), questObjectiveType(QN1, TYPE), questObjectiveType(QN2, TYPE), QN1 != QN2. %Two quests cannot have the same target

%Kill quest target rules
:- questTarget(QN, T), questObjectiveType(QN, kill), not npc(T). %The target must be an actual npcs
:- questTarget(QN, T), questObjectiveType(QN, kill), not hostile(T). %The target must be a hostile npc

%fetch quest target rules

%Quest stage rules
stageRange(1..maxQuestStages). %range of allowable quest stages

{ alive(NPCN,S) : npcNumRange(NPCN) : stageRange(S) }. %npc NPCN is alive during stage S
{ dead(NPCN,S) : npcNumRange(NPCN) : stageRange(S) }. %npc NPCN is dead during stage S

:- alive(NPCN, S), dead(NPCN, S). %an npc cannot be both dead and alive at the same time
alive(NPCN,1) :- npc(NPCN). %all npcs are alive at stage 1 FOR NOW

%only bother keeping track of alive/dead status for actual npcs during actual quest stages
:- alive(NPCN, SN), not npc(NPCN). 
:- dead(NPCN, SN), not npc(NPCN). 
:- alive(NPCN, SN), not stage(SN). 
:- dead(NPCN, SN), not stage(SN). 


{ playerAt(L,S) : level(L) : stageRange(S) }. %Level the player is in at Stage S

%Possible actions
action(getQuest).
%action(move).
%action(kill).

1 { stageAction(SN,A) : stageRange(SN) : action(A) } 1. %Action A occurs at stage SN (Note no support yet for multiple branches)
:- stageAction(SN,A1), stageAction(SN,A2), A1 != A2. %currently only one action can occur per stage
stage(SN) :- stageAction(SN,A). %if an action occurs at a stage that stage exists
:- stage(SN), not stage((SN - 1)), SN != 1. %Every stage has to have a stage before it or be the first stage

%Get quest action
1 { getQuest(NPCN, SN) : stageRange(SN) : npcNumRange(NPCN) } 1 :- stageAction(SN,getQuest). %A getQuest action requires a npc to be specified to get the quest from
%:- getQuest(NPCN,SN), npcLocation(NPCN,X,Y,L1), playerAt(L2,SN), L1 != L2. %The player must be in the location of the quest giver to get a quest
:- getQuest(NPCN,SN), not npc(NPCN). %the quest giver must actually exist
%constraint to check that npc is the quest giver

%-----------------------------------------
%Fixed Elements
%------------------------------------
levelLengthX(8,indoor_dungeon).
levelLengthY(8,indoor_dungeon).
playerAt(outdoors,1). 